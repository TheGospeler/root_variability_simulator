<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>root_simulator.root_simulator API documentation</title>
<meta name="description" content="The root_simulator module is the computational engine of the root_simulator package." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>root_simulator.root_simulator</code></h1>
</header>
<section id="section-intro">
<p>The root_simulator module is the computational engine of the root_simulator package.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;The root_simulator module is the computational engine of the root_simulator package.&#34;&#34;&#34;

import os
from pygimli.physics import ert
from IPython.display import HTML, clear_output
import imageio
import matplotlib.pyplot as plt
import numpy as np
import pygimli as pg
import pygimli.meshtools as mt
import root_simulator.read_res_data as rrd


class RootSimulator:
    &#34;&#34;&#34;The Root simulator simulates the spatial distribution of tree roots at the subsurface.

    The RootSimulator class contains functions that enables the simulations of the subsurface to
    access the spatial variability of roots using created synthetic data to simulate the model
      accuracy and to create Electrical Resistivity Tomography (ERT).
    This package makes use of the python library for Geophysical modeling and Inversion (pyGIMLi).

    Dependable: numpy, matplotlib, pygimli.

    Functions
    ----------
    create_geom: creates an arbitrary region of the subsurface with a specific feature.
    forward_model: simulates the resistivity distribution within the created mesh.
    inversion_2D: performs simulations and return the true resistivity model.
    animate_simulation: visualizes the results of the different array configuration.

    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;Initialize global variable.&#34;&#34;&#34;
        self.mesh = &#39;Run create_mesh&#39;
        self.geometry = &#39;Run create_geom&#39;
        self.scheme = &#39;Run the create_mesh&#39;
        # private inherent variables needed
        self.__rhomap = &#39;&#39;  # Makes the value of the input rhomap global
        self.__inv_data = &#39;&#39;  # Stores the data from the forward model, we can use for inversion
        self.__x_start = &#39;&#39;  # The starting point of the electrode array
        self.__x_stop = &#39;&#39;  # The ending point of the electrode array
        self.__layer = &#39;&#39;  # Used for setting up the depth of the para_domain during inversion
        self.__sch = &#39;&#39;  # used in the animate_simulation to create unique names of the models
        self.__unstructured_mesh_inv = &#39;&#39;
        self.__inversion = &#39;&#39;
        self.__manager = &#39;&#39;  # will store the inverted data

    def create_geom(self, x_ext, y_ext, layer, feature):
        &#34;&#34;&#34;Create a 2D array using finite element method in the pygimli package.

        parameters
        ----------
        x_ext: The horizontal extension (x_axis). Should be a list... [end, start]
        y_ext: The depth profile. y_ext must be a negative value, since we are investigating
               below the subsurface.
        layer: A slice within the depth profile we want to investigate&gt;&gt; [start, end]
        feature: A nested list containing (x, y) nodes of the feature within the confinement
                 of the layer.

        Example-- create_geom(x_ext=[50, -50], y_ext= -50,layer=[-1, -20],
                              feature=[(-10, -1), (17, -8), (5,-1)])

        &#34;&#34;&#34;
        # Check for errors in input parameter.

        # reassign the global y_ext
        self.__layer = layer
        # creates the dimension of the given size in the subsurface.
        world = mt.createWorld(start=[y_ext, 0], end=x_ext, layers=layer, worldMarker=True)
        # creates the feature architecture in the subsurface
        root_feature = mt.createPolygon(feature, isClosed=True, addNodes=3, marker=4)
        # integrate the feature to the layer under consideration.
        self.geometry = world + root_feature

        return self.geometry

    def display_geometry(self):
        &#34;&#34;&#34;Display all the components created at the subsurface.&#34;&#34;&#34;
        return pg.show(self.geometry)

    def create_mesh(self, scheme_name, start=-30, end=30, num=21, mesh_quality=34):
        &#34;&#34;&#34;create a desired electrode configuration used investigate feature.

        parameters
        ----------
        scheme_name: should be one out of the following &#39;dd&#39;, &#39;wa&#39;, &#39;wb&#39;, &#39;pp&#39;, &#39;slm&#39;, &#39;pd&#39;.
                     where wa- wenner alpha, slm- schlumberger, pp- pole-pole, dd- dipole-dipole
        start: commencing points should be at least 10 meter within the layer boundary
        end: ending points should also be at least 10 meter within the end of the layer boundary.
        num: num of electrode spacing.
        mesh_quality: 34 should be the maximum. The smaller the mesh the faster the computation.

        &#34;&#34;&#34;
        if scheme_name.lower() not in [&#39;dd&#39;, &#39;wa&#39;, &#39;wb&#39;, &#39;pp&#39;, &#39;slm&#39;, &#39;pd&#39;]:
            raise ValueError(f&#34;{scheme_name} is not a valid scheme_name. Review documentation&#34;)

        self.scheme = ert.createData(elecs=np.linspace(start=start, stop=end, num=num),
                                     schemeName=scheme_name)
        # Update the selected scheme
        self.__sch = scheme_name
        # incorporate the created electrode configuration scheme inside the geometry
        for pos in self.scheme.sensors():
            self.geometry.createNode(pos)
            # adds refinement nodes in a distance of 10% of electrode spacing
            self.geometry.createNode(pos - [0, 0.1])

        # reassign the global electrode configuration
        self.__x_start = start
        self.__x_stop = end

        self.mesh = mt.createMesh(self.geometry, quality=mesh_quality)
        return self.mesh

    def plot_rhomap(self, rhomap):
        &#34;&#34;&#34;Visualize the resistivity distribution within the mesh.

        parameter
        ---------
        rhomap: nested list consisting of the region and the associated resistivity value.

        example &gt;&gt; rhomap =[[1, 100], [2, 75], [4, 50], ...]
        The example above have four regions. This is dependent on the nature of the geometry,
        layer, and feature created.

        if the depth profile starts from 0, there will be only three regions in the overall
        geometry, and thus only three resistivity map values will be needed, tied to the
        region (marker). visualizing the geometry will help knowing the marker of each region.
        &#34;&#34;&#34;
        self.__rhomap = rhomap
        return pg.show(self.mesh, data=self.__rhomap, label=pg.unit(&#39;res&#39;), showMesh=True)

    def display_mesh(self):
        &#34;&#34;&#34;Plot the subsurface with the created mesh&#34;&#34;&#34;
        return pg.show(self.mesh)

    def forward_model(self, rhomap):
        &#34;&#34;&#34;Simulate the interpolation of the mesh, scheme and resistivity values.

        parameter
        ---------
        rhomap: resistivity of the region. For simplicity, use the regional rhomap available,
                if the individual points are not available.
        &#34;&#34;&#34;
        data = ert.simulate(self.mesh, scheme=self.scheme, res=rhomap, noiseLevel=1,
                            noiseAbs=1e-6, seed=1337)
        # remove the values below 0
        data.remove(data[&#39;rhoa&#39;] &lt; 0)
        # print out the confirmation of the minimum value
        pg.info(&#39;Filtered rhoa (min/max)&#39;, min(data[&#39;rhoa&#39;]), max(data[&#39;rhoa&#39;]))
        self.__inv_data = data

        return ert.show(data, label=pg.unit(&#39;res&#39;))

    def inversion2d(self, para_depth=30):
        &#34;&#34;&#34;Create an inversion of the forward model to produce the feature and the layers.

        parameter
        ---------
        para_depth: the slice of the depth containing our feature
        &#34;&#34;&#34;
        self.__manager = ert.ERTManager(self.__inv_data)
        self.__inversion = self.__manager.invert(lam=20, verbose=True, paraDepth=para_depth)

        # performs the inversion calculations and plots the inversion.
        self.__manager.showResultAndFit()
        # reassign the inversion result to the unstructured_mesh_inv
        self.__unstructured_mesh_inv = pg.Mesh(self.__manager.paraDomain)

        # perform regularization on the inverted profile
        __run_regularized = self.__perform_grid_regularization()

    def __perform_grid_regularization(self):
        # creates a regular grid for the inversion.
        x_pos = np.linspace(self.__x_start, self.__x_stop, 33)
        y_pos = pg.cat([0], pg.utils.grange(0.5, self.__layer[1], n=5))

        inversion_domain = pg.createGrid(x=x_pos, y=y_pos[::-1], marker=2)
        grid = pg.meshtools.appendBoundary(inversion_domain, marker=1, xbound=50, ybound=50)
        inversion_model = self.__manager.invert(self.__inv_data, mesh=grid, lam=20, verbose=True)
        __model_para_depth = self.__manager.paraModel(inversion_model)
        return __model_para_depth

    def display_inverted_img(self):
        &#34;&#34;&#34;Display the inverted Image in a regular Mesh.&#34;&#34;&#34;
        # plot the result of the inversion...
        _, axis = plt.subplots(1, 1)
        self.__manager.showResult(ax=axis, cMin=25, hold=True, cMax=150)
        axis.set_title(&#39;Inversion regular grid&#39;)

    def __true_model(self):
        &#34;&#34;&#34;Plot and save the true model in figures directory.&#34;&#34;&#34;
        # create directory for figures if not already created.
        if not os.path.isdir(&#39;figures&#39;):
            os.makedirs(&#39;figures&#39;)

        # Plot the &#39;True Model&#39; of the Simulation
        fig, axis = plt.subplots(1, 1, figsize=(8, 6))
        pg.show(self.mesh, self.__rhomap, ax=axis, hold=True, cMap=&#34;Spectral_r&#34;, logScale=True,
                cMin=25, cMax=150, label=pg.unit(&#39;res&#39;))
        axis.set_title(&#39;True Model&#39;)
        axis.set_xlim(self.__manager.paraDomain.xmin(), self.__manager.paraDomain.xmax())
        axis.set_ylim(self.__manager.paraDomain.ymin(), self.__manager.paraDomain.ymax())
        plt.savefig(f&#39;figures/TM_{self.__sch}.png&#39;)
        fig.clear()
        clear_output(wait=True)

    def __unstructured_mesh(self):
        &#34;&#34;&#34;Plot and save the inversion unstructured mesh model in figures directory.&#34;&#34;&#34;
        fig, axis = plt.subplots(1, 1, figsize=(8, 6))
        pg.show(self.__unstructured_mesh_inv, self.__inversion, ax=axis, hold=True,
                cMap=&#34;Spectral_r&#34;, logScale=True,
                cMin=25, cMax=150, label=pg.unit(&#39;res&#39;))
        axis.set_title(&#39;Inversion unstructured mesh&#39;)
        axis.set_xlim(self.__manager.paraDomain.xmin(), self.__manager.paraDomain.xmax())
        axis.set_ylim(self.__manager.paraDomain.ymin(), self.__manager.paraDomain.ymax())
        plt.savefig(f&#39;figures/IU_{self.__sch}.png&#39;)
        fig.clear()
        clear_output(wait=True)

    def __regular_mesh(self):
        &#34;&#34;&#34;Plot and save the inversion a regular grid model in figures directory.&#34;&#34;&#34;
        fig, axis = plt.subplots(1, 1, figsize=(8, 6))
        self.__manager.showResult(ax=axis, cMin=25, hold=True, cMax=150)
        axis.set_title(&#39;Inversion regular grid&#39;)
        axis.set_xlim(self.__manager.paraDomain.xmin(), self.__manager.paraDomain.xmax())
        axis.set_ylim(self.__manager.paraDomain.ymin(), self.__manager.paraDomain.ymax())
        plt.savefig(f&#39;figures/IR_{self.__sch}.png&#39;)
        fig.clear()
        clear_output(wait=True)

    def animate_simulation(self):
        &#34;&#34;&#34;Animate the transitions of three model simulations.

        The RootSimulator class simulates three models, and the animate_simulator function
        visualizes the image of the subsurface using the three models created from the synthetic
        data. The three models are the True model (which is the actual representation of the
        subsurface), the inversion using unstructured mesh, and the inversion with a regularized
        mesh.

        In Practice we may not truly identify the true model, but this is a good way to access
        the model performance with the known structure or layers under consideration; with such
        information, we can measure the performance of unknown structures with real data.
        &#34;&#34;&#34;
        # initiate all of the models to enable saving their functions at in the figures folder
        print(&#39;Running True Model......&#39;)
        self.__true_model()
        print(&#39;Running Inversion with Unstructured Mesh Model......&#39;)
        self.__unstructured_mesh()
        print(&#39;Running Inversion with regularized grid Model......&#39;)
        clear_output(wait=True)
        print(&#39;Preparing Animation......&#39;)
        self.__regular_mesh()
        print(&#39;Starting Animation......&#39;)

        # create the animation and save it in the figures folder
        with imageio.get_writer(f&#39;figures/res_mod_{self.__sch}.gif&#39;, mode=&#39;I&#39;, duration=1)\
                as writer:
            for filename in [f&#39;TM_{self.__sch}.png&#39;, f&#39;IU_{self.__sch}.png&#39;,
                             f&#39;IR_{self.__sch}.png&#39;]:
                image = imageio.imread(f&#39;figures/{filename}&#39;)
                writer.append_data(image)
        return HTML(f&#39;&lt;img src=&#34;figures/res_mod_{self.__sch}.gif&#34;&gt;&#39;)


class RootSimulator2:
    &#34;&#34;&#34;Produce the Forward and Inverse model of the processed supersting file.

    The RootSimulator2 class performs two major modeling to the processed data. The two main
    functions are the forward_model and inverse_model that enables the simulations of the
    surveyed subsurface using the resulting supersting.stg file.

    The raw file is processed using the standardized_bert function in the read_res_data module to
    produce the .dat file for the inversion simulation, while the data for the forward model is
    obtained via the supersting_processing to produce the *_res.dat

    This package makes use of the python library for Geophysical modeling and Inversion (pyGIMLi).

    Dependable: read_res_data, numpy, matplotlib, pygimli.

    Parameter
    ----------
    data - raw supersting file *.stg

    Functions
    ----------
    forward_model: Returns the model of the apparent resistivity across the profile.
    inverse_model: Returns the true resistivity of the subsurface under investigation.
    &#34;&#34;&#34;

    def __init__(self, data):
        &#34;&#34;&#34;Input data should be in the .dat format.

        The .dat file can be obtained using the standardized_bert function in the read_res_data
        module.&#34;&#34;&#34;
        self.data = data
        self.mesh = &#34;Run generate_mesh&#34;
        self.__data_tr = &#39;&#39;  # stores the read in data
        self.__sim = &#39;&#39;
        self.__tr_res = &#39;&#39;

    def __activate_data(self):
        &#34;&#34;&#34;Activate variables for general use.&#34;&#34;&#34;
        # Ensure the write data file is used for the class
        if not os.path.isfile(self.data):
            raise ValueError(f&#34;{self.data} does not exist, make sure file is in the same directory&#34;)
        if self.data[-4:] != &#39;.stg&#39;:
            raise ValueError(f&#34;{self.data} is not a supersting file. Input a supersting file (.stg)&#34;)

        # Updates the global variable to be used across boards
        self.__data_tr = rrd.standardized_bert(self.data)
        self.__data_tr[&#34;err&#34;] = ert.estimateError(self.__data_tr, relativeError=0.02)
        return self.__data_tr

    def generate_mesh(self, boundary=200, depth=200, quality=34.5):
        &#34;&#34;&#34;Generate the mesh for the inversion simulations.

        Parameters
        ----------
        boundary: The extent of allowance of current flow during the inversion calculations
                  (Margin for parameter domain in absolute sensor distances).
        depth: The depth we want to investigate (The Maximum depth for parametric domain).
        quality: Number of notes. High value creates more refined nodes. 34.5 is the maximum
        &#34;&#34;&#34;
        # activate the data
        self.__activate_data()
        self.mesh = mt.createParaMesh(self.__data_tr.sensorPositions(), paraDX=0.5, paraDepth=200,
                                      paraBoundary=boundary, boundary=depth, quality=quality)
        return pg.show(self.mesh, markers=True)

    def forward_model(self):
        &#34;&#34;&#34;Plots the apparent resistivity based on the x-position and Depth of Investigation.

        Visualizing the subsurface to filter outliers are a necessity to obtaining an optimal
        inversion results. Hence, the forward_model helps visualize the data and recognize the
        general distribution of the resistivity of the subsurface.
        &#34;&#34;&#34;
        file = rrd.supersting_processing(self.data)
        # Get the midpoint with the resistivity value and plot estimation
        data = file[file[:, 1] &gt; 0] # scale data to remove negative resistivity (anomalous data)

        # create dictionary to store position and depth of each electrode configuration
        data_bank = {}

        # Get the rows containing Wenner array based on the configuration arrangement
        wen_arr = data[data[:, 5] &gt; data[:, 2]]

        # midpoint of the mn electrode &gt;&gt; (n-m/2) + m for wenner array
        # the addition of m is to maintain the exact location of the midpoint.
        x_pos_wa = ((wen_arr[:, 11] - wen_arr[:, 8]) / 2) + wen_arr[:, 8]
        depth_wa = 0.2 * (wen_arr[:, 5] - wen_arr[:, 2])  # 0.2*AB

        # update dictionary
        data_bank[&#39;Wenner Array&#39;] = [x_pos_wa, depth_wa, wen_arr]

        # Get the rows containing dipole-dipole based on the configuration arrangement
        dip_dip = data[data[:, 5] &lt; data[:, 2]]

        x_pos_dd = ((dip_dip[:, 5] - dip_dip[:, 8]) / 2) + dip_dip[:, 8]  # dip_dip ~ BA
        depth_dd = abs(0.2 * (dip_dip[:, 2] - dip_dip[:, 11]))  # 0.2*BN
        # update dictionary
        data_bank[&#39;Dipole-Dipole&#39;] = [x_pos_dd, depth_dd, dip_dip]

        # Plot the two electrode configuration models
        for arr_name, values in data_bank.items():
            fig, axis = plt.subplots(figsize=(10, 7))
            info = axis.scatter(values[0], values[1], s=75, c=values[2][:, 1])
            axis.set_xlabel(&#39;Distance (m)&#39;)
            axis.xaxis.tick_top()
            axis.xaxis.set_label_position(&#39;top&#39;)
            axis.set_ylabel(&#39;Depth (m)&#39;)
            axis.invert_yaxis()  # Transforms the data to start from depth 0 - 25 meters
            axis.set_title(arr_name, fontweight=&#39;bold&#39;)
            fig.colorbar(info, orientation=&#39;horizontal&#39;, label=&#39;Res (Ωm)&#39;)

    def inverse_simulation(self):
        &#34;&#34;&#34;Inversion Modeling of the Resistivity Data.&#34;&#34;&#34;
        print(&#34;Creating regions....&#34;)
        simulate = ert.ERTModelling(sr=False)
        simulate.setMesh(self.mesh)
        simulate.data = self.__activate_data()
        simulate.setRegionProperties(1, background=True)
        # reassigning global variable
        self.__sim = simulate

        print(&#34;Starting Inversions ...&#34;)
        trans_log = pg.trans.TransLog()
        calc_inversion = pg.Inversion(fop=simulate, verbose=True)
        calc_inversion.transData = trans_log
        calc_inversion.transModel = trans_log

        true_resistivity = calc_inversion.run(self.__data_tr[&#39;rhoa&#39;], self.__data_tr[&#39;err&#39;], lam=20)
        self.__tr_res = true_resistivity

        return pg.show(simulate.paraDomain, true_resistivity, colorBar=True, cMap=&#34;Spectral_r&#34;,
                       cMin=8, cMax=1500, label=pg.unit(&#39;res&#39;))

    def plot_inverse(self, min_res=8, max_res=1500):
        &#34;&#34;&#34;print and edit the inverse_simulation Image.

        parameters
        ---------
        min_res: The lowest resistivity values based on the simulation
        max_res: The highest resistivity values based on the simulation
        &#34;&#34;&#34;
        return pg.show(self.__sim.paraDomain, self.__tr_res, colorBar=True, cMap=&#34;Spectral_r&#34;,
                       cMin=min_res, cMax=max_res, label=pg.unit(&#39;res&#39;))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="root_simulator.root_simulator.RootSimulator"><code class="flex name class">
<span>class <span class="ident">RootSimulator</span></span>
</code></dt>
<dd>
<div class="desc"><p>The Root simulator simulates the spatial distribution of tree roots at the subsurface.</p>
<p>The RootSimulator class contains functions that enables the simulations of the subsurface to
access the spatial variability of roots using created synthetic data to simulate the model
accuracy and to create Electrical Resistivity Tomography (ERT).
This package makes use of the python library for Geophysical modeling and Inversion (pyGIMLi).</p>
<p>Dependable: numpy, matplotlib, pygimli.</p>
<h2 id="functions">Functions</h2>
<p>create_geom: creates an arbitrary region of the subsurface with a specific feature.
forward_model: simulates the resistivity distribution within the created mesh.
inversion_2D: performs simulations and return the true resistivity model.
animate_simulation: visualizes the results of the different array configuration.</p>
<p>Initialize global variable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RootSimulator:
    &#34;&#34;&#34;The Root simulator simulates the spatial distribution of tree roots at the subsurface.

    The RootSimulator class contains functions that enables the simulations of the subsurface to
    access the spatial variability of roots using created synthetic data to simulate the model
      accuracy and to create Electrical Resistivity Tomography (ERT).
    This package makes use of the python library for Geophysical modeling and Inversion (pyGIMLi).

    Dependable: numpy, matplotlib, pygimli.

    Functions
    ----------
    create_geom: creates an arbitrary region of the subsurface with a specific feature.
    forward_model: simulates the resistivity distribution within the created mesh.
    inversion_2D: performs simulations and return the true resistivity model.
    animate_simulation: visualizes the results of the different array configuration.

    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;Initialize global variable.&#34;&#34;&#34;
        self.mesh = &#39;Run create_mesh&#39;
        self.geometry = &#39;Run create_geom&#39;
        self.scheme = &#39;Run the create_mesh&#39;
        # private inherent variables needed
        self.__rhomap = &#39;&#39;  # Makes the value of the input rhomap global
        self.__inv_data = &#39;&#39;  # Stores the data from the forward model, we can use for inversion
        self.__x_start = &#39;&#39;  # The starting point of the electrode array
        self.__x_stop = &#39;&#39;  # The ending point of the electrode array
        self.__layer = &#39;&#39;  # Used for setting up the depth of the para_domain during inversion
        self.__sch = &#39;&#39;  # used in the animate_simulation to create unique names of the models
        self.__unstructured_mesh_inv = &#39;&#39;
        self.__inversion = &#39;&#39;
        self.__manager = &#39;&#39;  # will store the inverted data

    def create_geom(self, x_ext, y_ext, layer, feature):
        &#34;&#34;&#34;Create a 2D array using finite element method in the pygimli package.

        parameters
        ----------
        x_ext: The horizontal extension (x_axis). Should be a list... [end, start]
        y_ext: The depth profile. y_ext must be a negative value, since we are investigating
               below the subsurface.
        layer: A slice within the depth profile we want to investigate&gt;&gt; [start, end]
        feature: A nested list containing (x, y) nodes of the feature within the confinement
                 of the layer.

        Example-- create_geom(x_ext=[50, -50], y_ext= -50,layer=[-1, -20],
                              feature=[(-10, -1), (17, -8), (5,-1)])

        &#34;&#34;&#34;
        # Check for errors in input parameter.

        # reassign the global y_ext
        self.__layer = layer
        # creates the dimension of the given size in the subsurface.
        world = mt.createWorld(start=[y_ext, 0], end=x_ext, layers=layer, worldMarker=True)
        # creates the feature architecture in the subsurface
        root_feature = mt.createPolygon(feature, isClosed=True, addNodes=3, marker=4)
        # integrate the feature to the layer under consideration.
        self.geometry = world + root_feature

        return self.geometry

    def display_geometry(self):
        &#34;&#34;&#34;Display all the components created at the subsurface.&#34;&#34;&#34;
        return pg.show(self.geometry)

    def create_mesh(self, scheme_name, start=-30, end=30, num=21, mesh_quality=34):
        &#34;&#34;&#34;create a desired electrode configuration used investigate feature.

        parameters
        ----------
        scheme_name: should be one out of the following &#39;dd&#39;, &#39;wa&#39;, &#39;wb&#39;, &#39;pp&#39;, &#39;slm&#39;, &#39;pd&#39;.
                     where wa- wenner alpha, slm- schlumberger, pp- pole-pole, dd- dipole-dipole
        start: commencing points should be at least 10 meter within the layer boundary
        end: ending points should also be at least 10 meter within the end of the layer boundary.
        num: num of electrode spacing.
        mesh_quality: 34 should be the maximum. The smaller the mesh the faster the computation.

        &#34;&#34;&#34;
        if scheme_name.lower() not in [&#39;dd&#39;, &#39;wa&#39;, &#39;wb&#39;, &#39;pp&#39;, &#39;slm&#39;, &#39;pd&#39;]:
            raise ValueError(f&#34;{scheme_name} is not a valid scheme_name. Review documentation&#34;)

        self.scheme = ert.createData(elecs=np.linspace(start=start, stop=end, num=num),
                                     schemeName=scheme_name)
        # Update the selected scheme
        self.__sch = scheme_name
        # incorporate the created electrode configuration scheme inside the geometry
        for pos in self.scheme.sensors():
            self.geometry.createNode(pos)
            # adds refinement nodes in a distance of 10% of electrode spacing
            self.geometry.createNode(pos - [0, 0.1])

        # reassign the global electrode configuration
        self.__x_start = start
        self.__x_stop = end

        self.mesh = mt.createMesh(self.geometry, quality=mesh_quality)
        return self.mesh

    def plot_rhomap(self, rhomap):
        &#34;&#34;&#34;Visualize the resistivity distribution within the mesh.

        parameter
        ---------
        rhomap: nested list consisting of the region and the associated resistivity value.

        example &gt;&gt; rhomap =[[1, 100], [2, 75], [4, 50], ...]
        The example above have four regions. This is dependent on the nature of the geometry,
        layer, and feature created.

        if the depth profile starts from 0, there will be only three regions in the overall
        geometry, and thus only three resistivity map values will be needed, tied to the
        region (marker). visualizing the geometry will help knowing the marker of each region.
        &#34;&#34;&#34;
        self.__rhomap = rhomap
        return pg.show(self.mesh, data=self.__rhomap, label=pg.unit(&#39;res&#39;), showMesh=True)

    def display_mesh(self):
        &#34;&#34;&#34;Plot the subsurface with the created mesh&#34;&#34;&#34;
        return pg.show(self.mesh)

    def forward_model(self, rhomap):
        &#34;&#34;&#34;Simulate the interpolation of the mesh, scheme and resistivity values.

        parameter
        ---------
        rhomap: resistivity of the region. For simplicity, use the regional rhomap available,
                if the individual points are not available.
        &#34;&#34;&#34;
        data = ert.simulate(self.mesh, scheme=self.scheme, res=rhomap, noiseLevel=1,
                            noiseAbs=1e-6, seed=1337)
        # remove the values below 0
        data.remove(data[&#39;rhoa&#39;] &lt; 0)
        # print out the confirmation of the minimum value
        pg.info(&#39;Filtered rhoa (min/max)&#39;, min(data[&#39;rhoa&#39;]), max(data[&#39;rhoa&#39;]))
        self.__inv_data = data

        return ert.show(data, label=pg.unit(&#39;res&#39;))

    def inversion2d(self, para_depth=30):
        &#34;&#34;&#34;Create an inversion of the forward model to produce the feature and the layers.

        parameter
        ---------
        para_depth: the slice of the depth containing our feature
        &#34;&#34;&#34;
        self.__manager = ert.ERTManager(self.__inv_data)
        self.__inversion = self.__manager.invert(lam=20, verbose=True, paraDepth=para_depth)

        # performs the inversion calculations and plots the inversion.
        self.__manager.showResultAndFit()
        # reassign the inversion result to the unstructured_mesh_inv
        self.__unstructured_mesh_inv = pg.Mesh(self.__manager.paraDomain)

        # perform regularization on the inverted profile
        __run_regularized = self.__perform_grid_regularization()

    def __perform_grid_regularization(self):
        # creates a regular grid for the inversion.
        x_pos = np.linspace(self.__x_start, self.__x_stop, 33)
        y_pos = pg.cat([0], pg.utils.grange(0.5, self.__layer[1], n=5))

        inversion_domain = pg.createGrid(x=x_pos, y=y_pos[::-1], marker=2)
        grid = pg.meshtools.appendBoundary(inversion_domain, marker=1, xbound=50, ybound=50)
        inversion_model = self.__manager.invert(self.__inv_data, mesh=grid, lam=20, verbose=True)
        __model_para_depth = self.__manager.paraModel(inversion_model)
        return __model_para_depth

    def display_inverted_img(self):
        &#34;&#34;&#34;Display the inverted Image in a regular Mesh.&#34;&#34;&#34;
        # plot the result of the inversion...
        _, axis = plt.subplots(1, 1)
        self.__manager.showResult(ax=axis, cMin=25, hold=True, cMax=150)
        axis.set_title(&#39;Inversion regular grid&#39;)

    def __true_model(self):
        &#34;&#34;&#34;Plot and save the true model in figures directory.&#34;&#34;&#34;
        # create directory for figures if not already created.
        if not os.path.isdir(&#39;figures&#39;):
            os.makedirs(&#39;figures&#39;)

        # Plot the &#39;True Model&#39; of the Simulation
        fig, axis = plt.subplots(1, 1, figsize=(8, 6))
        pg.show(self.mesh, self.__rhomap, ax=axis, hold=True, cMap=&#34;Spectral_r&#34;, logScale=True,
                cMin=25, cMax=150, label=pg.unit(&#39;res&#39;))
        axis.set_title(&#39;True Model&#39;)
        axis.set_xlim(self.__manager.paraDomain.xmin(), self.__manager.paraDomain.xmax())
        axis.set_ylim(self.__manager.paraDomain.ymin(), self.__manager.paraDomain.ymax())
        plt.savefig(f&#39;figures/TM_{self.__sch}.png&#39;)
        fig.clear()
        clear_output(wait=True)

    def __unstructured_mesh(self):
        &#34;&#34;&#34;Plot and save the inversion unstructured mesh model in figures directory.&#34;&#34;&#34;
        fig, axis = plt.subplots(1, 1, figsize=(8, 6))
        pg.show(self.__unstructured_mesh_inv, self.__inversion, ax=axis, hold=True,
                cMap=&#34;Spectral_r&#34;, logScale=True,
                cMin=25, cMax=150, label=pg.unit(&#39;res&#39;))
        axis.set_title(&#39;Inversion unstructured mesh&#39;)
        axis.set_xlim(self.__manager.paraDomain.xmin(), self.__manager.paraDomain.xmax())
        axis.set_ylim(self.__manager.paraDomain.ymin(), self.__manager.paraDomain.ymax())
        plt.savefig(f&#39;figures/IU_{self.__sch}.png&#39;)
        fig.clear()
        clear_output(wait=True)

    def __regular_mesh(self):
        &#34;&#34;&#34;Plot and save the inversion a regular grid model in figures directory.&#34;&#34;&#34;
        fig, axis = plt.subplots(1, 1, figsize=(8, 6))
        self.__manager.showResult(ax=axis, cMin=25, hold=True, cMax=150)
        axis.set_title(&#39;Inversion regular grid&#39;)
        axis.set_xlim(self.__manager.paraDomain.xmin(), self.__manager.paraDomain.xmax())
        axis.set_ylim(self.__manager.paraDomain.ymin(), self.__manager.paraDomain.ymax())
        plt.savefig(f&#39;figures/IR_{self.__sch}.png&#39;)
        fig.clear()
        clear_output(wait=True)

    def animate_simulation(self):
        &#34;&#34;&#34;Animate the transitions of three model simulations.

        The RootSimulator class simulates three models, and the animate_simulator function
        visualizes the image of the subsurface using the three models created from the synthetic
        data. The three models are the True model (which is the actual representation of the
        subsurface), the inversion using unstructured mesh, and the inversion with a regularized
        mesh.

        In Practice we may not truly identify the true model, but this is a good way to access
        the model performance with the known structure or layers under consideration; with such
        information, we can measure the performance of unknown structures with real data.
        &#34;&#34;&#34;
        # initiate all of the models to enable saving their functions at in the figures folder
        print(&#39;Running True Model......&#39;)
        self.__true_model()
        print(&#39;Running Inversion with Unstructured Mesh Model......&#39;)
        self.__unstructured_mesh()
        print(&#39;Running Inversion with regularized grid Model......&#39;)
        clear_output(wait=True)
        print(&#39;Preparing Animation......&#39;)
        self.__regular_mesh()
        print(&#39;Starting Animation......&#39;)

        # create the animation and save it in the figures folder
        with imageio.get_writer(f&#39;figures/res_mod_{self.__sch}.gif&#39;, mode=&#39;I&#39;, duration=1)\
                as writer:
            for filename in [f&#39;TM_{self.__sch}.png&#39;, f&#39;IU_{self.__sch}.png&#39;,
                             f&#39;IR_{self.__sch}.png&#39;]:
                image = imageio.imread(f&#39;figures/{filename}&#39;)
                writer.append_data(image)
        return HTML(f&#39;&lt;img src=&#34;figures/res_mod_{self.__sch}.gif&#34;&gt;&#39;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="root_simulator.root_simulator.RootSimulator.animate_simulation"><code class="name flex">
<span>def <span class="ident">animate_simulation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Animate the transitions of three model simulations.</p>
<p>The RootSimulator class simulates three models, and the animate_simulator function
visualizes the image of the subsurface using the three models created from the synthetic
data. The three models are the True model (which is the actual representation of the
subsurface), the inversion using unstructured mesh, and the inversion with a regularized
mesh.</p>
<p>In Practice we may not truly identify the true model, but this is a good way to access
the model performance with the known structure or layers under consideration; with such
information, we can measure the performance of unknown structures with real data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def animate_simulation(self):
    &#34;&#34;&#34;Animate the transitions of three model simulations.

    The RootSimulator class simulates three models, and the animate_simulator function
    visualizes the image of the subsurface using the three models created from the synthetic
    data. The three models are the True model (which is the actual representation of the
    subsurface), the inversion using unstructured mesh, and the inversion with a regularized
    mesh.

    In Practice we may not truly identify the true model, but this is a good way to access
    the model performance with the known structure or layers under consideration; with such
    information, we can measure the performance of unknown structures with real data.
    &#34;&#34;&#34;
    # initiate all of the models to enable saving their functions at in the figures folder
    print(&#39;Running True Model......&#39;)
    self.__true_model()
    print(&#39;Running Inversion with Unstructured Mesh Model......&#39;)
    self.__unstructured_mesh()
    print(&#39;Running Inversion with regularized grid Model......&#39;)
    clear_output(wait=True)
    print(&#39;Preparing Animation......&#39;)
    self.__regular_mesh()
    print(&#39;Starting Animation......&#39;)

    # create the animation and save it in the figures folder
    with imageio.get_writer(f&#39;figures/res_mod_{self.__sch}.gif&#39;, mode=&#39;I&#39;, duration=1)\
            as writer:
        for filename in [f&#39;TM_{self.__sch}.png&#39;, f&#39;IU_{self.__sch}.png&#39;,
                         f&#39;IR_{self.__sch}.png&#39;]:
            image = imageio.imread(f&#39;figures/{filename}&#39;)
            writer.append_data(image)
    return HTML(f&#39;&lt;img src=&#34;figures/res_mod_{self.__sch}.gif&#34;&gt;&#39;)</code></pre>
</details>
</dd>
<dt id="root_simulator.root_simulator.RootSimulator.create_geom"><code class="name flex">
<span>def <span class="ident">create_geom</span></span>(<span>self, x_ext, y_ext, layer, feature)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a 2D array using finite element method in the pygimli package.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x_ext</code></strong> :&ensp;<code>The horizontal extension (x_axis). Should be a list&hellip; [end, start]</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>y_ext</code></strong> :&ensp;<code>The depth profile. y_ext must be a negative value, since we are investigating</code></dt>
<dd>below the subsurface.</dd>
<dt><strong><code>layer</code></strong> :&ensp;<code>A slice within the depth profile we want to investigate&gt;&gt; [start, end]</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>feature</code></strong> :&ensp;<code>A nested list containing (x, y) nodes</code> of <code>the feature within the confinement</code></dt>
<dd>of the layer.</dd>
</dl>
<p>Example&ndash; create_geom(x_ext=[50, -50], y_ext= -50,layer=[-1, -20],
feature=[(-10, -1), (17, -8), (5,-1)])</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_geom(self, x_ext, y_ext, layer, feature):
    &#34;&#34;&#34;Create a 2D array using finite element method in the pygimli package.

    parameters
    ----------
    x_ext: The horizontal extension (x_axis). Should be a list... [end, start]
    y_ext: The depth profile. y_ext must be a negative value, since we are investigating
           below the subsurface.
    layer: A slice within the depth profile we want to investigate&gt;&gt; [start, end]
    feature: A nested list containing (x, y) nodes of the feature within the confinement
             of the layer.

    Example-- create_geom(x_ext=[50, -50], y_ext= -50,layer=[-1, -20],
                          feature=[(-10, -1), (17, -8), (5,-1)])

    &#34;&#34;&#34;
    # Check for errors in input parameter.

    # reassign the global y_ext
    self.__layer = layer
    # creates the dimension of the given size in the subsurface.
    world = mt.createWorld(start=[y_ext, 0], end=x_ext, layers=layer, worldMarker=True)
    # creates the feature architecture in the subsurface
    root_feature = mt.createPolygon(feature, isClosed=True, addNodes=3, marker=4)
    # integrate the feature to the layer under consideration.
    self.geometry = world + root_feature

    return self.geometry</code></pre>
</details>
</dd>
<dt id="root_simulator.root_simulator.RootSimulator.create_mesh"><code class="name flex">
<span>def <span class="ident">create_mesh</span></span>(<span>self, scheme_name, start=-30, end=30, num=21, mesh_quality=34)</span>
</code></dt>
<dd>
<div class="desc"><p>create a desired electrode configuration used investigate feature.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt>scheme_name: should be one out of the following 'dd', 'wa', 'wb', 'pp', 'slm', 'pd'.</dt>
<dt>where wa- wenner alpha, slm- schlumberger, pp- pole-pole, dd- dipole-dipole</dt>
<dt><strong><code>start</code></strong> :&ensp;<code>commencing points should be at least 10 meter within the layer boundary</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>end: ending points should also be at least 10 meter within the end of the layer boundary.
num: num of electrode spacing.
mesh_quality: 34 should be the maximum. The smaller the mesh the faster the computation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_mesh(self, scheme_name, start=-30, end=30, num=21, mesh_quality=34):
    &#34;&#34;&#34;create a desired electrode configuration used investigate feature.

    parameters
    ----------
    scheme_name: should be one out of the following &#39;dd&#39;, &#39;wa&#39;, &#39;wb&#39;, &#39;pp&#39;, &#39;slm&#39;, &#39;pd&#39;.
                 where wa- wenner alpha, slm- schlumberger, pp- pole-pole, dd- dipole-dipole
    start: commencing points should be at least 10 meter within the layer boundary
    end: ending points should also be at least 10 meter within the end of the layer boundary.
    num: num of electrode spacing.
    mesh_quality: 34 should be the maximum. The smaller the mesh the faster the computation.

    &#34;&#34;&#34;
    if scheme_name.lower() not in [&#39;dd&#39;, &#39;wa&#39;, &#39;wb&#39;, &#39;pp&#39;, &#39;slm&#39;, &#39;pd&#39;]:
        raise ValueError(f&#34;{scheme_name} is not a valid scheme_name. Review documentation&#34;)

    self.scheme = ert.createData(elecs=np.linspace(start=start, stop=end, num=num),
                                 schemeName=scheme_name)
    # Update the selected scheme
    self.__sch = scheme_name
    # incorporate the created electrode configuration scheme inside the geometry
    for pos in self.scheme.sensors():
        self.geometry.createNode(pos)
        # adds refinement nodes in a distance of 10% of electrode spacing
        self.geometry.createNode(pos - [0, 0.1])

    # reassign the global electrode configuration
    self.__x_start = start
    self.__x_stop = end

    self.mesh = mt.createMesh(self.geometry, quality=mesh_quality)
    return self.mesh</code></pre>
</details>
</dd>
<dt id="root_simulator.root_simulator.RootSimulator.display_geometry"><code class="name flex">
<span>def <span class="ident">display_geometry</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Display all the components created at the subsurface.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_geometry(self):
    &#34;&#34;&#34;Display all the components created at the subsurface.&#34;&#34;&#34;
    return pg.show(self.geometry)</code></pre>
</details>
</dd>
<dt id="root_simulator.root_simulator.RootSimulator.display_inverted_img"><code class="name flex">
<span>def <span class="ident">display_inverted_img</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Display the inverted Image in a regular Mesh.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_inverted_img(self):
    &#34;&#34;&#34;Display the inverted Image in a regular Mesh.&#34;&#34;&#34;
    # plot the result of the inversion...
    _, axis = plt.subplots(1, 1)
    self.__manager.showResult(ax=axis, cMin=25, hold=True, cMax=150)
    axis.set_title(&#39;Inversion regular grid&#39;)</code></pre>
</details>
</dd>
<dt id="root_simulator.root_simulator.RootSimulator.display_mesh"><code class="name flex">
<span>def <span class="ident">display_mesh</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot the subsurface with the created mesh</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_mesh(self):
    &#34;&#34;&#34;Plot the subsurface with the created mesh&#34;&#34;&#34;
    return pg.show(self.mesh)</code></pre>
</details>
</dd>
<dt id="root_simulator.root_simulator.RootSimulator.forward_model"><code class="name flex">
<span>def <span class="ident">forward_model</span></span>(<span>self, rhomap)</span>
</code></dt>
<dd>
<div class="desc"><p>Simulate the interpolation of the mesh, scheme and resistivity values.</p>
<h2 id="parameter">Parameter</h2>
<p>rhomap: resistivity of the region. For simplicity, use the regional rhomap available,
if the individual points are not available.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def forward_model(self, rhomap):
    &#34;&#34;&#34;Simulate the interpolation of the mesh, scheme and resistivity values.

    parameter
    ---------
    rhomap: resistivity of the region. For simplicity, use the regional rhomap available,
            if the individual points are not available.
    &#34;&#34;&#34;
    data = ert.simulate(self.mesh, scheme=self.scheme, res=rhomap, noiseLevel=1,
                        noiseAbs=1e-6, seed=1337)
    # remove the values below 0
    data.remove(data[&#39;rhoa&#39;] &lt; 0)
    # print out the confirmation of the minimum value
    pg.info(&#39;Filtered rhoa (min/max)&#39;, min(data[&#39;rhoa&#39;]), max(data[&#39;rhoa&#39;]))
    self.__inv_data = data

    return ert.show(data, label=pg.unit(&#39;res&#39;))</code></pre>
</details>
</dd>
<dt id="root_simulator.root_simulator.RootSimulator.inversion2d"><code class="name flex">
<span>def <span class="ident">inversion2d</span></span>(<span>self, para_depth=30)</span>
</code></dt>
<dd>
<div class="desc"><p>Create an inversion of the forward model to produce the feature and the layers.</p>
<h2 id="parameter">Parameter</h2>
<p>para_depth: the slice of the depth containing our feature</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inversion2d(self, para_depth=30):
    &#34;&#34;&#34;Create an inversion of the forward model to produce the feature and the layers.

    parameter
    ---------
    para_depth: the slice of the depth containing our feature
    &#34;&#34;&#34;
    self.__manager = ert.ERTManager(self.__inv_data)
    self.__inversion = self.__manager.invert(lam=20, verbose=True, paraDepth=para_depth)

    # performs the inversion calculations and plots the inversion.
    self.__manager.showResultAndFit()
    # reassign the inversion result to the unstructured_mesh_inv
    self.__unstructured_mesh_inv = pg.Mesh(self.__manager.paraDomain)

    # perform regularization on the inverted profile
    __run_regularized = self.__perform_grid_regularization()</code></pre>
</details>
</dd>
<dt id="root_simulator.root_simulator.RootSimulator.plot_rhomap"><code class="name flex">
<span>def <span class="ident">plot_rhomap</span></span>(<span>self, rhomap)</span>
</code></dt>
<dd>
<div class="desc"><p>Visualize the resistivity distribution within the mesh.</p>
<h2 id="parameter">Parameter</h2>
<p>rhomap: nested list consisting of the region and the associated resistivity value.</p>
<p>example &gt;&gt; rhomap =[[1, 100], [2, 75], [4, 50], &hellip;]
The example above have four regions. This is dependent on the nature of the geometry,
layer, and feature created.</p>
<p>if the depth profile starts from 0, there will be only three regions in the overall
geometry, and thus only three resistivity map values will be needed, tied to the
region (marker). visualizing the geometry will help knowing the marker of each region.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_rhomap(self, rhomap):
    &#34;&#34;&#34;Visualize the resistivity distribution within the mesh.

    parameter
    ---------
    rhomap: nested list consisting of the region and the associated resistivity value.

    example &gt;&gt; rhomap =[[1, 100], [2, 75], [4, 50], ...]
    The example above have four regions. This is dependent on the nature of the geometry,
    layer, and feature created.

    if the depth profile starts from 0, there will be only three regions in the overall
    geometry, and thus only three resistivity map values will be needed, tied to the
    region (marker). visualizing the geometry will help knowing the marker of each region.
    &#34;&#34;&#34;
    self.__rhomap = rhomap
    return pg.show(self.mesh, data=self.__rhomap, label=pg.unit(&#39;res&#39;), showMesh=True)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="root_simulator.root_simulator.RootSimulator2"><code class="flex name class">
<span>class <span class="ident">RootSimulator2</span></span>
<span>(</span><span>data)</span>
</code></dt>
<dd>
<div class="desc"><p>Produce the Forward and Inverse model of the processed supersting file.</p>
<p>The RootSimulator2 class performs two major modeling to the processed data. The two main
functions are the forward_model and inverse_model that enables the simulations of the
surveyed subsurface using the resulting supersting.stg file.</p>
<p>The raw file is processed using the standardized_bert function in the read_res_data module to
produce the .dat file for the inversion simulation, while the data for the forward model is
obtained via the supersting_processing to produce the *_res.dat</p>
<p>This package makes use of the python library for Geophysical modeling and Inversion (pyGIMLi).</p>
<p>Dependable: read_res_data, numpy, matplotlib, pygimli.</p>
<h2 id="parameter">Parameter</h2>
<p>data - raw supersting file *.stg</p>
<h2 id="functions">Functions</h2>
<p>forward_model: Returns the model of the apparent resistivity across the profile.
inverse_model: Returns the true resistivity of the subsurface under investigation.</p>
<p>Input data should be in the .dat format.</p>
<p>The .dat file can be obtained using the standardized_bert function in the read_res_data
module.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RootSimulator2:
    &#34;&#34;&#34;Produce the Forward and Inverse model of the processed supersting file.

    The RootSimulator2 class performs two major modeling to the processed data. The two main
    functions are the forward_model and inverse_model that enables the simulations of the
    surveyed subsurface using the resulting supersting.stg file.

    The raw file is processed using the standardized_bert function in the read_res_data module to
    produce the .dat file for the inversion simulation, while the data for the forward model is
    obtained via the supersting_processing to produce the *_res.dat

    This package makes use of the python library for Geophysical modeling and Inversion (pyGIMLi).

    Dependable: read_res_data, numpy, matplotlib, pygimli.

    Parameter
    ----------
    data - raw supersting file *.stg

    Functions
    ----------
    forward_model: Returns the model of the apparent resistivity across the profile.
    inverse_model: Returns the true resistivity of the subsurface under investigation.
    &#34;&#34;&#34;

    def __init__(self, data):
        &#34;&#34;&#34;Input data should be in the .dat format.

        The .dat file can be obtained using the standardized_bert function in the read_res_data
        module.&#34;&#34;&#34;
        self.data = data
        self.mesh = &#34;Run generate_mesh&#34;
        self.__data_tr = &#39;&#39;  # stores the read in data
        self.__sim = &#39;&#39;
        self.__tr_res = &#39;&#39;

    def __activate_data(self):
        &#34;&#34;&#34;Activate variables for general use.&#34;&#34;&#34;
        # Ensure the write data file is used for the class
        if not os.path.isfile(self.data):
            raise ValueError(f&#34;{self.data} does not exist, make sure file is in the same directory&#34;)
        if self.data[-4:] != &#39;.stg&#39;:
            raise ValueError(f&#34;{self.data} is not a supersting file. Input a supersting file (.stg)&#34;)

        # Updates the global variable to be used across boards
        self.__data_tr = rrd.standardized_bert(self.data)
        self.__data_tr[&#34;err&#34;] = ert.estimateError(self.__data_tr, relativeError=0.02)
        return self.__data_tr

    def generate_mesh(self, boundary=200, depth=200, quality=34.5):
        &#34;&#34;&#34;Generate the mesh for the inversion simulations.

        Parameters
        ----------
        boundary: The extent of allowance of current flow during the inversion calculations
                  (Margin for parameter domain in absolute sensor distances).
        depth: The depth we want to investigate (The Maximum depth for parametric domain).
        quality: Number of notes. High value creates more refined nodes. 34.5 is the maximum
        &#34;&#34;&#34;
        # activate the data
        self.__activate_data()
        self.mesh = mt.createParaMesh(self.__data_tr.sensorPositions(), paraDX=0.5, paraDepth=200,
                                      paraBoundary=boundary, boundary=depth, quality=quality)
        return pg.show(self.mesh, markers=True)

    def forward_model(self):
        &#34;&#34;&#34;Plots the apparent resistivity based on the x-position and Depth of Investigation.

        Visualizing the subsurface to filter outliers are a necessity to obtaining an optimal
        inversion results. Hence, the forward_model helps visualize the data and recognize the
        general distribution of the resistivity of the subsurface.
        &#34;&#34;&#34;
        file = rrd.supersting_processing(self.data)
        # Get the midpoint with the resistivity value and plot estimation
        data = file[file[:, 1] &gt; 0] # scale data to remove negative resistivity (anomalous data)

        # create dictionary to store position and depth of each electrode configuration
        data_bank = {}

        # Get the rows containing Wenner array based on the configuration arrangement
        wen_arr = data[data[:, 5] &gt; data[:, 2]]

        # midpoint of the mn electrode &gt;&gt; (n-m/2) + m for wenner array
        # the addition of m is to maintain the exact location of the midpoint.
        x_pos_wa = ((wen_arr[:, 11] - wen_arr[:, 8]) / 2) + wen_arr[:, 8]
        depth_wa = 0.2 * (wen_arr[:, 5] - wen_arr[:, 2])  # 0.2*AB

        # update dictionary
        data_bank[&#39;Wenner Array&#39;] = [x_pos_wa, depth_wa, wen_arr]

        # Get the rows containing dipole-dipole based on the configuration arrangement
        dip_dip = data[data[:, 5] &lt; data[:, 2]]

        x_pos_dd = ((dip_dip[:, 5] - dip_dip[:, 8]) / 2) + dip_dip[:, 8]  # dip_dip ~ BA
        depth_dd = abs(0.2 * (dip_dip[:, 2] - dip_dip[:, 11]))  # 0.2*BN
        # update dictionary
        data_bank[&#39;Dipole-Dipole&#39;] = [x_pos_dd, depth_dd, dip_dip]

        # Plot the two electrode configuration models
        for arr_name, values in data_bank.items():
            fig, axis = plt.subplots(figsize=(10, 7))
            info = axis.scatter(values[0], values[1], s=75, c=values[2][:, 1])
            axis.set_xlabel(&#39;Distance (m)&#39;)
            axis.xaxis.tick_top()
            axis.xaxis.set_label_position(&#39;top&#39;)
            axis.set_ylabel(&#39;Depth (m)&#39;)
            axis.invert_yaxis()  # Transforms the data to start from depth 0 - 25 meters
            axis.set_title(arr_name, fontweight=&#39;bold&#39;)
            fig.colorbar(info, orientation=&#39;horizontal&#39;, label=&#39;Res (Ωm)&#39;)

    def inverse_simulation(self):
        &#34;&#34;&#34;Inversion Modeling of the Resistivity Data.&#34;&#34;&#34;
        print(&#34;Creating regions....&#34;)
        simulate = ert.ERTModelling(sr=False)
        simulate.setMesh(self.mesh)
        simulate.data = self.__activate_data()
        simulate.setRegionProperties(1, background=True)
        # reassigning global variable
        self.__sim = simulate

        print(&#34;Starting Inversions ...&#34;)
        trans_log = pg.trans.TransLog()
        calc_inversion = pg.Inversion(fop=simulate, verbose=True)
        calc_inversion.transData = trans_log
        calc_inversion.transModel = trans_log

        true_resistivity = calc_inversion.run(self.__data_tr[&#39;rhoa&#39;], self.__data_tr[&#39;err&#39;], lam=20)
        self.__tr_res = true_resistivity

        return pg.show(simulate.paraDomain, true_resistivity, colorBar=True, cMap=&#34;Spectral_r&#34;,
                       cMin=8, cMax=1500, label=pg.unit(&#39;res&#39;))

    def plot_inverse(self, min_res=8, max_res=1500):
        &#34;&#34;&#34;print and edit the inverse_simulation Image.

        parameters
        ---------
        min_res: The lowest resistivity values based on the simulation
        max_res: The highest resistivity values based on the simulation
        &#34;&#34;&#34;
        return pg.show(self.__sim.paraDomain, self.__tr_res, colorBar=True, cMap=&#34;Spectral_r&#34;,
                       cMin=min_res, cMax=max_res, label=pg.unit(&#39;res&#39;))</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="root_simulator.root_simulator.RootSimulator2.forward_model"><code class="name flex">
<span>def <span class="ident">forward_model</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the apparent resistivity based on the x-position and Depth of Investigation.</p>
<p>Visualizing the subsurface to filter outliers are a necessity to obtaining an optimal
inversion results. Hence, the forward_model helps visualize the data and recognize the
general distribution of the resistivity of the subsurface.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def forward_model(self):
    &#34;&#34;&#34;Plots the apparent resistivity based on the x-position and Depth of Investigation.

    Visualizing the subsurface to filter outliers are a necessity to obtaining an optimal
    inversion results. Hence, the forward_model helps visualize the data and recognize the
    general distribution of the resistivity of the subsurface.
    &#34;&#34;&#34;
    file = rrd.supersting_processing(self.data)
    # Get the midpoint with the resistivity value and plot estimation
    data = file[file[:, 1] &gt; 0] # scale data to remove negative resistivity (anomalous data)

    # create dictionary to store position and depth of each electrode configuration
    data_bank = {}

    # Get the rows containing Wenner array based on the configuration arrangement
    wen_arr = data[data[:, 5] &gt; data[:, 2]]

    # midpoint of the mn electrode &gt;&gt; (n-m/2) + m for wenner array
    # the addition of m is to maintain the exact location of the midpoint.
    x_pos_wa = ((wen_arr[:, 11] - wen_arr[:, 8]) / 2) + wen_arr[:, 8]
    depth_wa = 0.2 * (wen_arr[:, 5] - wen_arr[:, 2])  # 0.2*AB

    # update dictionary
    data_bank[&#39;Wenner Array&#39;] = [x_pos_wa, depth_wa, wen_arr]

    # Get the rows containing dipole-dipole based on the configuration arrangement
    dip_dip = data[data[:, 5] &lt; data[:, 2]]

    x_pos_dd = ((dip_dip[:, 5] - dip_dip[:, 8]) / 2) + dip_dip[:, 8]  # dip_dip ~ BA
    depth_dd = abs(0.2 * (dip_dip[:, 2] - dip_dip[:, 11]))  # 0.2*BN
    # update dictionary
    data_bank[&#39;Dipole-Dipole&#39;] = [x_pos_dd, depth_dd, dip_dip]

    # Plot the two electrode configuration models
    for arr_name, values in data_bank.items():
        fig, axis = plt.subplots(figsize=(10, 7))
        info = axis.scatter(values[0], values[1], s=75, c=values[2][:, 1])
        axis.set_xlabel(&#39;Distance (m)&#39;)
        axis.xaxis.tick_top()
        axis.xaxis.set_label_position(&#39;top&#39;)
        axis.set_ylabel(&#39;Depth (m)&#39;)
        axis.invert_yaxis()  # Transforms the data to start from depth 0 - 25 meters
        axis.set_title(arr_name, fontweight=&#39;bold&#39;)
        fig.colorbar(info, orientation=&#39;horizontal&#39;, label=&#39;Res (Ωm)&#39;)</code></pre>
</details>
</dd>
<dt id="root_simulator.root_simulator.RootSimulator2.generate_mesh"><code class="name flex">
<span>def <span class="ident">generate_mesh</span></span>(<span>self, boundary=200, depth=200, quality=34.5)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate the mesh for the inversion simulations.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>boundary</code></strong> :&ensp;<code>The extent</code> of <code>allowance</code> of <code>current flow during the inversion calculations</code></dt>
<dd>(Margin for parameter domain in absolute sensor distances).</dd>
<dt>depth: The depth we want to investigate (The Maximum depth for parametric domain).</dt>
<dt><strong><code>quality</code></strong> :&ensp;<code>Number</code> of <code>notes. High value creates more refined nodes. 34.5 is the maximum</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_mesh(self, boundary=200, depth=200, quality=34.5):
    &#34;&#34;&#34;Generate the mesh for the inversion simulations.

    Parameters
    ----------
    boundary: The extent of allowance of current flow during the inversion calculations
              (Margin for parameter domain in absolute sensor distances).
    depth: The depth we want to investigate (The Maximum depth for parametric domain).
    quality: Number of notes. High value creates more refined nodes. 34.5 is the maximum
    &#34;&#34;&#34;
    # activate the data
    self.__activate_data()
    self.mesh = mt.createParaMesh(self.__data_tr.sensorPositions(), paraDX=0.5, paraDepth=200,
                                  paraBoundary=boundary, boundary=depth, quality=quality)
    return pg.show(self.mesh, markers=True)</code></pre>
</details>
</dd>
<dt id="root_simulator.root_simulator.RootSimulator2.inverse_simulation"><code class="name flex">
<span>def <span class="ident">inverse_simulation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Inversion Modeling of the Resistivity Data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inverse_simulation(self):
    &#34;&#34;&#34;Inversion Modeling of the Resistivity Data.&#34;&#34;&#34;
    print(&#34;Creating regions....&#34;)
    simulate = ert.ERTModelling(sr=False)
    simulate.setMesh(self.mesh)
    simulate.data = self.__activate_data()
    simulate.setRegionProperties(1, background=True)
    # reassigning global variable
    self.__sim = simulate

    print(&#34;Starting Inversions ...&#34;)
    trans_log = pg.trans.TransLog()
    calc_inversion = pg.Inversion(fop=simulate, verbose=True)
    calc_inversion.transData = trans_log
    calc_inversion.transModel = trans_log

    true_resistivity = calc_inversion.run(self.__data_tr[&#39;rhoa&#39;], self.__data_tr[&#39;err&#39;], lam=20)
    self.__tr_res = true_resistivity

    return pg.show(simulate.paraDomain, true_resistivity, colorBar=True, cMap=&#34;Spectral_r&#34;,
                   cMin=8, cMax=1500, label=pg.unit(&#39;res&#39;))</code></pre>
</details>
</dd>
<dt id="root_simulator.root_simulator.RootSimulator2.plot_inverse"><code class="name flex">
<span>def <span class="ident">plot_inverse</span></span>(<span>self, min_res=8, max_res=1500)</span>
</code></dt>
<dd>
<div class="desc"><p>print and edit the inverse_simulation Image.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>min_res</code></strong> :&ensp;<code>The lowest resistivity values based on the simulation</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>max_res</code></strong> :&ensp;<code>The highest resistivity values based on the simulation</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_inverse(self, min_res=8, max_res=1500):
    &#34;&#34;&#34;print and edit the inverse_simulation Image.

    parameters
    ---------
    min_res: The lowest resistivity values based on the simulation
    max_res: The highest resistivity values based on the simulation
    &#34;&#34;&#34;
    return pg.show(self.__sim.paraDomain, self.__tr_res, colorBar=True, cMap=&#34;Spectral_r&#34;,
                   cMin=min_res, cMax=max_res, label=pg.unit(&#39;res&#39;))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="root_simulator" href="index.html">root_simulator</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="root_simulator.root_simulator.RootSimulator" href="#root_simulator.root_simulator.RootSimulator">RootSimulator</a></code></h4>
<ul class="">
<li><code><a title="root_simulator.root_simulator.RootSimulator.animate_simulation" href="#root_simulator.root_simulator.RootSimulator.animate_simulation">animate_simulation</a></code></li>
<li><code><a title="root_simulator.root_simulator.RootSimulator.create_geom" href="#root_simulator.root_simulator.RootSimulator.create_geom">create_geom</a></code></li>
<li><code><a title="root_simulator.root_simulator.RootSimulator.create_mesh" href="#root_simulator.root_simulator.RootSimulator.create_mesh">create_mesh</a></code></li>
<li><code><a title="root_simulator.root_simulator.RootSimulator.display_geometry" href="#root_simulator.root_simulator.RootSimulator.display_geometry">display_geometry</a></code></li>
<li><code><a title="root_simulator.root_simulator.RootSimulator.display_inverted_img" href="#root_simulator.root_simulator.RootSimulator.display_inverted_img">display_inverted_img</a></code></li>
<li><code><a title="root_simulator.root_simulator.RootSimulator.display_mesh" href="#root_simulator.root_simulator.RootSimulator.display_mesh">display_mesh</a></code></li>
<li><code><a title="root_simulator.root_simulator.RootSimulator.forward_model" href="#root_simulator.root_simulator.RootSimulator.forward_model">forward_model</a></code></li>
<li><code><a title="root_simulator.root_simulator.RootSimulator.inversion2d" href="#root_simulator.root_simulator.RootSimulator.inversion2d">inversion2d</a></code></li>
<li><code><a title="root_simulator.root_simulator.RootSimulator.plot_rhomap" href="#root_simulator.root_simulator.RootSimulator.plot_rhomap">plot_rhomap</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="root_simulator.root_simulator.RootSimulator2" href="#root_simulator.root_simulator.RootSimulator2">RootSimulator2</a></code></h4>
<ul class="">
<li><code><a title="root_simulator.root_simulator.RootSimulator2.forward_model" href="#root_simulator.root_simulator.RootSimulator2.forward_model">forward_model</a></code></li>
<li><code><a title="root_simulator.root_simulator.RootSimulator2.generate_mesh" href="#root_simulator.root_simulator.RootSimulator2.generate_mesh">generate_mesh</a></code></li>
<li><code><a title="root_simulator.root_simulator.RootSimulator2.inverse_simulation" href="#root_simulator.root_simulator.RootSimulator2.inverse_simulation">inverse_simulation</a></code></li>
<li><code><a title="root_simulator.root_simulator.RootSimulator2.plot_inverse" href="#root_simulator.root_simulator.RootSimulator2.plot_inverse">plot_inverse</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>