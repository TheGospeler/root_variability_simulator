<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>root_simulator API documentation</title>
<meta name="description" content="Import dependent modules." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>root_simulator</code></h1>
</header>
<section id="section-intro">
<p>Import dependent modules.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Import dependent modules.&#34;&#34;&#34;

import os
from pygimli.physics import ert
from IPython.display import HTML, clear_output
import imageio
import matplotlib.pyplot as plt
import numpy as np
import pygimli as pg
import pygimli.meshtools as mt


class RootSimulator:
    &#34;&#34;&#34;The Root simulator simulates the spatial distribution of tree roots at the subsurface.

    The RootSimulator class contains functions that enables the simulations of the subsurface to
    access the spatial variability of roots using created synthetic data to simulate the model
      accuracy and to create Electrical Resistivity Tomography (ERT).
    This package makes use of the python library for Geophysical modeling and Inversion (pyGIMLi).

    Dependable: numpy, matplotlib, pygimli.
    Functions
    ----------
    create_geom- creates an arbitrary region of the subsurface with a specific feature.
    forward_model - simulates the resistivity distribution within the created mesh.
    inversion_2D - performs simulations and return the true resistivity model.
    animate_simulation- visualizes the results of the different array configuration.

    Usage:
    from root_simulator import RootSimulator

    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;Initialize global variable.&#34;&#34;&#34;
        self.mesh = &#39;Run create_mesh&#39;
        self.geometry = &#39;Run create_geom&#39;
        self.scheme = &#39;Run the create_mesh&#39;
        # private inherent variables needed
        self.__rhomap = &#39;&#39;  # Makes the value of the input rhomap global
        self.__inv_data = &#39;&#39;  # Stores the data from the forward model, we can use for inversion
        self.__x_start = &#39;&#39;  # The starting point of the electrode array
        self.__x_stop = &#39;&#39;  # The ending point of the electrode array
        self.__layer = &#39;&#39;  # Used for setting up the depth of the para_domain during inversion
        self.__sch = &#39;&#39;  # used in the animate_simulation to create unique names of the models
        self.__unstructured_mesh_inv = &#39;&#39;
        self.__inversion = &#39;&#39;
        self.__manager = &#39;&#39;  # will store the inverted data

    def create_geom(self, x_ext, y_ext, layer, feature):
        &#34;&#34;&#34;Create a 2D array using finite element method in the pygimli package.

        parameters
        ----------
        x_ext: The horizontal extension (x_axis). Should be a list... [end, start]
        y_ext: The depth profile. y_ext must be a negative value, since we are investigating
               below the subsurface.
        layer: A slice within the depth profile we want to investigate&gt;&gt; [start, end]
        feature: A nested list containing (x, y) nodes of the feature within the confinement
                 of the layer.

        Example-- create_geom(x_ext=[50, -50], y_ext= -50,layer=[-1, -20],
                              feature=[(-10, -1), (17, -8), (5,-1)])

        &#34;&#34;&#34;
        # Check for errors in input parameter.

        # reassign the global y_ext
        self.__layer = layer
        # creates the dimension of the given size in the subsurface.
        world = mt.createWorld(start=[y_ext, 0], end=x_ext, layers=layer, worldMarker=True)
        # creates the feature architecture in the subsurface
        root_feature = mt.createPolygon(feature, isClosed=True, addNodes=3, marker=4)
        # integrate the feature to the layer under consideration.
        self.geometry = world + root_feature

        return self.geometry

    def display_geometry(self):
        &#34;&#34;&#34;Display all the components created at the subsurface.&#34;&#34;&#34;
        return pg.show(self.geometry)

    def create_mesh(self, scheme_name, start=-30, end=30, num=21, mesh_quality=34):
        &#34;&#34;&#34;create a desired electrode configuration used investigate feature.

        parameters
        ----------
        scheme_name: should be one out of the following &#39;dd&#39;, &#39;wa&#39;, &#39;wb&#39;, &#39;pp&#39;, &#39;slm&#39;, &#39;pd&#39;.
                     where wa- wenner alpha, slm- schlumberger, pp- pole-pole, dd- dipole-dipole
        start: commencing points should be at least 10 meter within the layer boundary
        end: ending points should also be at least 10 meter within the end of the layer boundary.
        num: num of electrode spacing.
        mesh_quality: 34 should be the maximum. The smaller the mesh the faster the computation.

        &#34;&#34;&#34;
        if scheme_name.lower() not in [&#39;dd&#39;, &#39;wa&#39;, &#39;wb&#39;, &#39;pp&#39;, &#39;slm&#39;, &#39;pd&#39;]:
            raise ValueError(f&#34;{scheme_name} is not a valid scheme_name. Review documentation&#34;)

        self.scheme = ert.createData(elecs=np.linspace(start=start, stop=end, num=num),
                                     schemeName=scheme_name)
        # Update the selected scheme
        self.__sch = scheme_name
        # incorporate the created electrode configuration scheme inside the geometry
        for pos in self.scheme.sensors():
            self.geometry.createNode(pos)
            # adds refinement nodes in a distance of 10% of electrode spacing
            self.geometry.createNode(pos - [0, 0.1])

        # reassign the global electrode configuration
        self.__x_start = start
        self.__x_stop = end

        self.mesh = mt.createMesh(self.geometry, quality=mesh_quality)
        return self.mesh

    def plot_rhomap(self, rhomap):
        &#34;&#34;&#34;Visualize the resistivity distribution within the mesh.

        parameter:
        rhomap: nested list consisting of the region and the associated resistivity value.
        example &gt;&gt; rhomap =[[1, 100], [2, 75], [4, 50], ...]
        The example above have four regions. This is dependent on the nature of the geometry,
        layer, and feature created.

        if the depth profile starts from 0, there will be only three regions in the overall
        geometry, and thus only three resistivity map values will be needed, tied to the
        region (marker). visualizing the geometry will help knowing the marker of each region.
        &#34;&#34;&#34;
        self.__rhomap = rhomap
        return pg.show(self.mesh, data=self.__rhomap, label=pg.unit(&#39;res&#39;), showMesh=True)

    def display_mesh(self):
        &#34;&#34;&#34;Plot the subsurface with the created mesh&#34;&#34;&#34;
        return pg.show(self.mesh)

    def forward_model(self, rhomap):
        &#34;&#34;&#34;Simulate the interpolation of the mesh, scheme and resistivity values.

        parameter
        ---------
        rhomap: resistivity of the region. For simplicity, use the regional rhomap available,
                if the individual points are not available.
        &#34;&#34;&#34;
        data = ert.simulate(self.mesh, scheme=self.scheme, res=rhomap, noiseLevel=1,
                            noiseAbs=1e-6, seed=1337)
        # remove the values below 0
        data.remove(data[&#39;rhoa&#39;] &lt; 0)
        # print out the confirmation of the minimum value
        pg.info(&#39;Filtered rhoa (min/max)&#39;, min(data[&#39;rhoa&#39;]), max(data[&#39;rhoa&#39;]))
        self.__inv_data = data

        return ert.show(data, label=pg.unit(&#39;res&#39;))

    def inversion2d(self, para_depth=30):
        &#34;&#34;&#34;Create an inversion of the forward model to produce the feature and the layers.

        parameter
        ---------
        para_depth: the slice of the depth containing our feature
        &#34;&#34;&#34;
        self.__manager = ert.ERTManager(self.__inv_data)
        self.__inversion = self.__manager.invert(lam=20, verbose=True, paraDepth=para_depth)

        # performs the inversion calculations and plots the inversion.
        self.__manager.showResultAndFit()
        # reassign the inversion result to the unstructured_mesh_inv
        self.__unstructured_mesh_inv = pg.Mesh(self.__manager.paraDomain)

        # perform regularization on the inverted profile
        __run_regularized = self.__perform_grid_regularization()

    def __perform_grid_regularization(self):
        # creates a regular grid for the inversion.
        x_pos = np.linspace(self.__x_start, self.__x_stop, 33)
        y_pos = pg.cat([0], pg.utils.grange(0.5, self.__layer[1], n=5))

        inversion_domain = pg.createGrid(x=x_pos, y=y_pos[::-1], marker=2)
        grid = pg.meshtools.appendBoundary(inversion_domain, marker=1, xbound=50, ybound=50)
        inversion_model = self.__manager.invert(self.__inv_data, mesh=grid, lam=20, verbose=True)
        __model_para_depth = self.__manager.paraModel(inversion_model)
        return __model_para_depth

    def display_inverted_img(self):
        &#34;&#34;&#34;Display the inverted Image in a regular Mesh.&#34;&#34;&#34;
        # plot the result of the inversion...
        _, axis = plt.subplots(1, 1)
        self.__manager.showResult(ax=axis, cMin=25, hold=True, cMax=150)
        axis.set_title(&#39;Inversion regular grid&#39;)

    def __true_model(self):
        &#34;&#34;&#34;Plot and save the true model in figures directory.&#34;&#34;&#34;
        # create directory for figures if not already created.
        if not os.path.isdir(&#39;figures&#39;):
            os.makedirs(&#39;figures&#39;)

        # Plot the &#39;True Model&#39; of the Simulation
        fig, axis = plt.subplots(1, 1, figsize=(8, 6))
        pg.show(self.mesh, self.__rhomap, ax=axis, hold=True, cMap=&#34;Spectral_r&#34;, logScale=True,
                cMin=25, cMax=150, label=pg.unit(&#39;res&#39;))
        axis.set_title(&#39;True Model&#39;)
        axis.set_xlim(self.__manager.paraDomain.xmin(), self.__manager.paraDomain.xmax())
        axis.set_ylim(self.__manager.paraDomain.ymin(), self.__manager.paraDomain.ymax())
        plt.savefig(f&#39;figures/TM_{self.__sch}.png&#39;)
        fig.clear()
        clear_output(wait=True)

    def __unstructured_mesh(self):
        &#34;&#34;&#34;Plot and save the inversion unstructured mesh model in figures directory.&#34;&#34;&#34;
        fig, axis = plt.subplots(1, 1, figsize=(8, 6))
        pg.show(self.__unstructured_mesh_inv, self.__inversion, ax=axis, hold=True,
                cMap=&#34;Spectral_r&#34;, logScale=True,
                cMin=25, cMax=150, label=pg.unit(&#39;res&#39;))
        axis.set_title(&#39;Inversion unstructured mesh&#39;)
        axis.set_xlim(self.__manager.paraDomain.xmin(), self.__manager.paraDomain.xmax())
        axis.set_ylim(self.__manager.paraDomain.ymin(), self.__manager.paraDomain.ymax())
        plt.savefig(f&#39;figures/IU_{self.__sch}.png&#39;)
        fig.clear()
        clear_output(wait=True)

    def __regular_mesh(self):
        &#34;&#34;&#34;Plot and save the inversion a regular grid model in figures directory.&#34;&#34;&#34;
        fig, axis = plt.subplots(1, 1, figsize=(8, 6))
        self.__manager.showResult(ax=axis, cMin=25, hold=True, cMax=150)
        axis.set_title(&#39;Inversion regular grid&#39;)
        axis.set_xlim(self.__manager.paraDomain.xmin(), self.__manager.paraDomain.xmax())
        axis.set_ylim(self.__manager.paraDomain.ymin(), self.__manager.paraDomain.ymax())
        plt.savefig(f&#39;figures/IR_{self.__sch}.png&#39;)
        fig.clear()
        clear_output(wait=True)

    def animate_simulation(self):
        &#34;&#34;&#34;Animate the transitions of three model simulations.

        The RootSimulator class simulates three models, and the animate_simulator function
        visualizes the image of the subsurface using the three models created from the synthetic
        data. The three models are the True model (which is the actual representation of the
        subsurface), the inversion using unstructured mesh, and the inversion with a regularized
        mesh.
        In Practice we may not truly identify the true model, but this is a good way to access
        the model performance with the known structure or layers under consideration, using such
        information to measure the performance with real data with unknown structures.
        &#34;&#34;&#34;
        # initiate all of the models to enable saving their functions at in the figures folder
        print(&#39;Running True Model......&#39;)
        self.__true_model()
        print(&#39;Running Inversion with Unstructured Mesh Model......&#39;)
        self.__unstructured_mesh()
        print(&#39;Running Inversion with regularized grid Model......&#39;)
        clear_output(wait=True)
        print(&#39;Preparing Animation......&#39;)
        self.__regular_mesh()
        print(&#39;Starting Animation......&#39;)

        # create the animation and save it in the figures folder
        with imageio.get_writer(f&#39;figures/res_mod_{self.__sch}.gif&#39;, mode=&#39;I&#39;, duration=1)\
                as writer:
            for filename in [f&#39;TM_{self.__sch}.png&#39;, f&#39;IU_{self.__sch}.png&#39;,
                             f&#39;IR_{self.__sch}.png&#39;]:
                image = imageio.imread(f&#39;figures/{filename}&#39;)
                writer.append_data(image)
        return HTML(f&#39;&lt;img src=&#34;figures/res_mod_{self.__sch}.gif&#34;&gt;&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="root_simulator.RootSimulator"><code class="flex name class">
<span>class <span class="ident">RootSimulator</span></span>
</code></dt>
<dd>
<div class="desc"><p>The Root simulator simulates the spatial distribution of tree roots at the subsurface.</p>
<p>The RootSimulator class contains functions that enables the simulations of the subsurface to
access the spatial variability of roots using created synthetic data to simulate the model
accuracy and to create Electrical Resistivity Tomography (ERT).
This package makes use of the python library for Geophysical modeling and Inversion (pyGIMLi).</p>
<p>Dependable: numpy, matplotlib, pygimli.
Functions</p>
<hr>
<p>create_geom- creates an arbitrary region of the subsurface with a specific feature.
forward_model - simulates the resistivity distribution within the created mesh.
inversion_2D - performs simulations and return the true resistivity model.
animate_simulation- visualizes the results of the different array configuration.</p>
<p>Usage:
from root_simulator import RootSimulator</p>
<p>Initialize global variable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RootSimulator:
    &#34;&#34;&#34;The Root simulator simulates the spatial distribution of tree roots at the subsurface.

    The RootSimulator class contains functions that enables the simulations of the subsurface to
    access the spatial variability of roots using created synthetic data to simulate the model
      accuracy and to create Electrical Resistivity Tomography (ERT).
    This package makes use of the python library for Geophysical modeling and Inversion (pyGIMLi).

    Dependable: numpy, matplotlib, pygimli.
    Functions
    ----------
    create_geom- creates an arbitrary region of the subsurface with a specific feature.
    forward_model - simulates the resistivity distribution within the created mesh.
    inversion_2D - performs simulations and return the true resistivity model.
    animate_simulation- visualizes the results of the different array configuration.

    Usage:
    from root_simulator import RootSimulator

    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;Initialize global variable.&#34;&#34;&#34;
        self.mesh = &#39;Run create_mesh&#39;
        self.geometry = &#39;Run create_geom&#39;
        self.scheme = &#39;Run the create_mesh&#39;
        # private inherent variables needed
        self.__rhomap = &#39;&#39;  # Makes the value of the input rhomap global
        self.__inv_data = &#39;&#39;  # Stores the data from the forward model, we can use for inversion
        self.__x_start = &#39;&#39;  # The starting point of the electrode array
        self.__x_stop = &#39;&#39;  # The ending point of the electrode array
        self.__layer = &#39;&#39;  # Used for setting up the depth of the para_domain during inversion
        self.__sch = &#39;&#39;  # used in the animate_simulation to create unique names of the models
        self.__unstructured_mesh_inv = &#39;&#39;
        self.__inversion = &#39;&#39;
        self.__manager = &#39;&#39;  # will store the inverted data

    def create_geom(self, x_ext, y_ext, layer, feature):
        &#34;&#34;&#34;Create a 2D array using finite element method in the pygimli package.

        parameters
        ----------
        x_ext: The horizontal extension (x_axis). Should be a list... [end, start]
        y_ext: The depth profile. y_ext must be a negative value, since we are investigating
               below the subsurface.
        layer: A slice within the depth profile we want to investigate&gt;&gt; [start, end]
        feature: A nested list containing (x, y) nodes of the feature within the confinement
                 of the layer.

        Example-- create_geom(x_ext=[50, -50], y_ext= -50,layer=[-1, -20],
                              feature=[(-10, -1), (17, -8), (5,-1)])

        &#34;&#34;&#34;
        # Check for errors in input parameter.

        # reassign the global y_ext
        self.__layer = layer
        # creates the dimension of the given size in the subsurface.
        world = mt.createWorld(start=[y_ext, 0], end=x_ext, layers=layer, worldMarker=True)
        # creates the feature architecture in the subsurface
        root_feature = mt.createPolygon(feature, isClosed=True, addNodes=3, marker=4)
        # integrate the feature to the layer under consideration.
        self.geometry = world + root_feature

        return self.geometry

    def display_geometry(self):
        &#34;&#34;&#34;Display all the components created at the subsurface.&#34;&#34;&#34;
        return pg.show(self.geometry)

    def create_mesh(self, scheme_name, start=-30, end=30, num=21, mesh_quality=34):
        &#34;&#34;&#34;create a desired electrode configuration used investigate feature.

        parameters
        ----------
        scheme_name: should be one out of the following &#39;dd&#39;, &#39;wa&#39;, &#39;wb&#39;, &#39;pp&#39;, &#39;slm&#39;, &#39;pd&#39;.
                     where wa- wenner alpha, slm- schlumberger, pp- pole-pole, dd- dipole-dipole
        start: commencing points should be at least 10 meter within the layer boundary
        end: ending points should also be at least 10 meter within the end of the layer boundary.
        num: num of electrode spacing.
        mesh_quality: 34 should be the maximum. The smaller the mesh the faster the computation.

        &#34;&#34;&#34;
        if scheme_name.lower() not in [&#39;dd&#39;, &#39;wa&#39;, &#39;wb&#39;, &#39;pp&#39;, &#39;slm&#39;, &#39;pd&#39;]:
            raise ValueError(f&#34;{scheme_name} is not a valid scheme_name. Review documentation&#34;)

        self.scheme = ert.createData(elecs=np.linspace(start=start, stop=end, num=num),
                                     schemeName=scheme_name)
        # Update the selected scheme
        self.__sch = scheme_name
        # incorporate the created electrode configuration scheme inside the geometry
        for pos in self.scheme.sensors():
            self.geometry.createNode(pos)
            # adds refinement nodes in a distance of 10% of electrode spacing
            self.geometry.createNode(pos - [0, 0.1])

        # reassign the global electrode configuration
        self.__x_start = start
        self.__x_stop = end

        self.mesh = mt.createMesh(self.geometry, quality=mesh_quality)
        return self.mesh

    def plot_rhomap(self, rhomap):
        &#34;&#34;&#34;Visualize the resistivity distribution within the mesh.

        parameter:
        rhomap: nested list consisting of the region and the associated resistivity value.
        example &gt;&gt; rhomap =[[1, 100], [2, 75], [4, 50], ...]
        The example above have four regions. This is dependent on the nature of the geometry,
        layer, and feature created.

        if the depth profile starts from 0, there will be only three regions in the overall
        geometry, and thus only three resistivity map values will be needed, tied to the
        region (marker). visualizing the geometry will help knowing the marker of each region.
        &#34;&#34;&#34;
        self.__rhomap = rhomap
        return pg.show(self.mesh, data=self.__rhomap, label=pg.unit(&#39;res&#39;), showMesh=True)

    def display_mesh(self):
        &#34;&#34;&#34;Plot the subsurface with the created mesh&#34;&#34;&#34;
        return pg.show(self.mesh)

    def forward_model(self, rhomap):
        &#34;&#34;&#34;Simulate the interpolation of the mesh, scheme and resistivity values.

        parameter
        ---------
        rhomap: resistivity of the region. For simplicity, use the regional rhomap available,
                if the individual points are not available.
        &#34;&#34;&#34;
        data = ert.simulate(self.mesh, scheme=self.scheme, res=rhomap, noiseLevel=1,
                            noiseAbs=1e-6, seed=1337)
        # remove the values below 0
        data.remove(data[&#39;rhoa&#39;] &lt; 0)
        # print out the confirmation of the minimum value
        pg.info(&#39;Filtered rhoa (min/max)&#39;, min(data[&#39;rhoa&#39;]), max(data[&#39;rhoa&#39;]))
        self.__inv_data = data

        return ert.show(data, label=pg.unit(&#39;res&#39;))

    def inversion2d(self, para_depth=30):
        &#34;&#34;&#34;Create an inversion of the forward model to produce the feature and the layers.

        parameter
        ---------
        para_depth: the slice of the depth containing our feature
        &#34;&#34;&#34;
        self.__manager = ert.ERTManager(self.__inv_data)
        self.__inversion = self.__manager.invert(lam=20, verbose=True, paraDepth=para_depth)

        # performs the inversion calculations and plots the inversion.
        self.__manager.showResultAndFit()
        # reassign the inversion result to the unstructured_mesh_inv
        self.__unstructured_mesh_inv = pg.Mesh(self.__manager.paraDomain)

        # perform regularization on the inverted profile
        __run_regularized = self.__perform_grid_regularization()

    def __perform_grid_regularization(self):
        # creates a regular grid for the inversion.
        x_pos = np.linspace(self.__x_start, self.__x_stop, 33)
        y_pos = pg.cat([0], pg.utils.grange(0.5, self.__layer[1], n=5))

        inversion_domain = pg.createGrid(x=x_pos, y=y_pos[::-1], marker=2)
        grid = pg.meshtools.appendBoundary(inversion_domain, marker=1, xbound=50, ybound=50)
        inversion_model = self.__manager.invert(self.__inv_data, mesh=grid, lam=20, verbose=True)
        __model_para_depth = self.__manager.paraModel(inversion_model)
        return __model_para_depth

    def display_inverted_img(self):
        &#34;&#34;&#34;Display the inverted Image in a regular Mesh.&#34;&#34;&#34;
        # plot the result of the inversion...
        _, axis = plt.subplots(1, 1)
        self.__manager.showResult(ax=axis, cMin=25, hold=True, cMax=150)
        axis.set_title(&#39;Inversion regular grid&#39;)

    def __true_model(self):
        &#34;&#34;&#34;Plot and save the true model in figures directory.&#34;&#34;&#34;
        # create directory for figures if not already created.
        if not os.path.isdir(&#39;figures&#39;):
            os.makedirs(&#39;figures&#39;)

        # Plot the &#39;True Model&#39; of the Simulation
        fig, axis = plt.subplots(1, 1, figsize=(8, 6))
        pg.show(self.mesh, self.__rhomap, ax=axis, hold=True, cMap=&#34;Spectral_r&#34;, logScale=True,
                cMin=25, cMax=150, label=pg.unit(&#39;res&#39;))
        axis.set_title(&#39;True Model&#39;)
        axis.set_xlim(self.__manager.paraDomain.xmin(), self.__manager.paraDomain.xmax())
        axis.set_ylim(self.__manager.paraDomain.ymin(), self.__manager.paraDomain.ymax())
        plt.savefig(f&#39;figures/TM_{self.__sch}.png&#39;)
        fig.clear()
        clear_output(wait=True)

    def __unstructured_mesh(self):
        &#34;&#34;&#34;Plot and save the inversion unstructured mesh model in figures directory.&#34;&#34;&#34;
        fig, axis = plt.subplots(1, 1, figsize=(8, 6))
        pg.show(self.__unstructured_mesh_inv, self.__inversion, ax=axis, hold=True,
                cMap=&#34;Spectral_r&#34;, logScale=True,
                cMin=25, cMax=150, label=pg.unit(&#39;res&#39;))
        axis.set_title(&#39;Inversion unstructured mesh&#39;)
        axis.set_xlim(self.__manager.paraDomain.xmin(), self.__manager.paraDomain.xmax())
        axis.set_ylim(self.__manager.paraDomain.ymin(), self.__manager.paraDomain.ymax())
        plt.savefig(f&#39;figures/IU_{self.__sch}.png&#39;)
        fig.clear()
        clear_output(wait=True)

    def __regular_mesh(self):
        &#34;&#34;&#34;Plot and save the inversion a regular grid model in figures directory.&#34;&#34;&#34;
        fig, axis = plt.subplots(1, 1, figsize=(8, 6))
        self.__manager.showResult(ax=axis, cMin=25, hold=True, cMax=150)
        axis.set_title(&#39;Inversion regular grid&#39;)
        axis.set_xlim(self.__manager.paraDomain.xmin(), self.__manager.paraDomain.xmax())
        axis.set_ylim(self.__manager.paraDomain.ymin(), self.__manager.paraDomain.ymax())
        plt.savefig(f&#39;figures/IR_{self.__sch}.png&#39;)
        fig.clear()
        clear_output(wait=True)

    def animate_simulation(self):
        &#34;&#34;&#34;Animate the transitions of three model simulations.

        The RootSimulator class simulates three models, and the animate_simulator function
        visualizes the image of the subsurface using the three models created from the synthetic
        data. The three models are the True model (which is the actual representation of the
        subsurface), the inversion using unstructured mesh, and the inversion with a regularized
        mesh.
        In Practice we may not truly identify the true model, but this is a good way to access
        the model performance with the known structure or layers under consideration, using such
        information to measure the performance with real data with unknown structures.
        &#34;&#34;&#34;
        # initiate all of the models to enable saving their functions at in the figures folder
        print(&#39;Running True Model......&#39;)
        self.__true_model()
        print(&#39;Running Inversion with Unstructured Mesh Model......&#39;)
        self.__unstructured_mesh()
        print(&#39;Running Inversion with regularized grid Model......&#39;)
        clear_output(wait=True)
        print(&#39;Preparing Animation......&#39;)
        self.__regular_mesh()
        print(&#39;Starting Animation......&#39;)

        # create the animation and save it in the figures folder
        with imageio.get_writer(f&#39;figures/res_mod_{self.__sch}.gif&#39;, mode=&#39;I&#39;, duration=1)\
                as writer:
            for filename in [f&#39;TM_{self.__sch}.png&#39;, f&#39;IU_{self.__sch}.png&#39;,
                             f&#39;IR_{self.__sch}.png&#39;]:
                image = imageio.imread(f&#39;figures/{filename}&#39;)
                writer.append_data(image)
        return HTML(f&#39;&lt;img src=&#34;figures/res_mod_{self.__sch}.gif&#34;&gt;&#39;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="root_simulator.RootSimulator.animate_simulation"><code class="name flex">
<span>def <span class="ident">animate_simulation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Animate the transitions of three model simulations.</p>
<p>The RootSimulator class simulates three models, and the animate_simulator function
visualizes the image of the subsurface using the three models created from the synthetic
data. The three models are the True model (which is the actual representation of the
subsurface), the inversion using unstructured mesh, and the inversion with a regularized
mesh.
In Practice we may not truly identify the true model, but this is a good way to access
the model performance with the known structure or layers under consideration, using such
information to measure the performance with real data with unknown structures.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def animate_simulation(self):
    &#34;&#34;&#34;Animate the transitions of three model simulations.

    The RootSimulator class simulates three models, and the animate_simulator function
    visualizes the image of the subsurface using the three models created from the synthetic
    data. The three models are the True model (which is the actual representation of the
    subsurface), the inversion using unstructured mesh, and the inversion with a regularized
    mesh.
    In Practice we may not truly identify the true model, but this is a good way to access
    the model performance with the known structure or layers under consideration, using such
    information to measure the performance with real data with unknown structures.
    &#34;&#34;&#34;
    # initiate all of the models to enable saving their functions at in the figures folder
    print(&#39;Running True Model......&#39;)
    self.__true_model()
    print(&#39;Running Inversion with Unstructured Mesh Model......&#39;)
    self.__unstructured_mesh()
    print(&#39;Running Inversion with regularized grid Model......&#39;)
    clear_output(wait=True)
    print(&#39;Preparing Animation......&#39;)
    self.__regular_mesh()
    print(&#39;Starting Animation......&#39;)

    # create the animation and save it in the figures folder
    with imageio.get_writer(f&#39;figures/res_mod_{self.__sch}.gif&#39;, mode=&#39;I&#39;, duration=1)\
            as writer:
        for filename in [f&#39;TM_{self.__sch}.png&#39;, f&#39;IU_{self.__sch}.png&#39;,
                         f&#39;IR_{self.__sch}.png&#39;]:
            image = imageio.imread(f&#39;figures/{filename}&#39;)
            writer.append_data(image)
    return HTML(f&#39;&lt;img src=&#34;figures/res_mod_{self.__sch}.gif&#34;&gt;&#39;)</code></pre>
</details>
</dd>
<dt id="root_simulator.RootSimulator.create_geom"><code class="name flex">
<span>def <span class="ident">create_geom</span></span>(<span>self, x_ext, y_ext, layer, feature)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a 2D array using finite element method in the pygimli package.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x_ext</code></strong> :&ensp;<code>The horizontal extension (x_axis). Should be a list&hellip; [end, start]</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>y_ext</code></strong> :&ensp;<code>The depth profile. y_ext must be a negative value, since we are investigating</code></dt>
<dd>below the subsurface.</dd>
<dt><strong><code>layer</code></strong> :&ensp;<code>A slice within the depth profile we want to investigate&gt;&gt; [start, end]</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>feature</code></strong> :&ensp;<code>A nested list containing (x, y) nodes</code> of <code>the feature within the confinement</code></dt>
<dd>of the layer.</dd>
</dl>
<p>Example&ndash; create_geom(x_ext=[50, -50], y_ext= -50,layer=[-1, -20],
feature=[(-10, -1), (17, -8), (5,-1)])</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_geom(self, x_ext, y_ext, layer, feature):
    &#34;&#34;&#34;Create a 2D array using finite element method in the pygimli package.

    parameters
    ----------
    x_ext: The horizontal extension (x_axis). Should be a list... [end, start]
    y_ext: The depth profile. y_ext must be a negative value, since we are investigating
           below the subsurface.
    layer: A slice within the depth profile we want to investigate&gt;&gt; [start, end]
    feature: A nested list containing (x, y) nodes of the feature within the confinement
             of the layer.

    Example-- create_geom(x_ext=[50, -50], y_ext= -50,layer=[-1, -20],
                          feature=[(-10, -1), (17, -8), (5,-1)])

    &#34;&#34;&#34;
    # Check for errors in input parameter.

    # reassign the global y_ext
    self.__layer = layer
    # creates the dimension of the given size in the subsurface.
    world = mt.createWorld(start=[y_ext, 0], end=x_ext, layers=layer, worldMarker=True)
    # creates the feature architecture in the subsurface
    root_feature = mt.createPolygon(feature, isClosed=True, addNodes=3, marker=4)
    # integrate the feature to the layer under consideration.
    self.geometry = world + root_feature

    return self.geometry</code></pre>
</details>
</dd>
<dt id="root_simulator.RootSimulator.create_mesh"><code class="name flex">
<span>def <span class="ident">create_mesh</span></span>(<span>self, scheme_name, start=-30, end=30, num=21, mesh_quality=34)</span>
</code></dt>
<dd>
<div class="desc"><p>create a desired electrode configuration used investigate feature.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt>scheme_name: should be one out of the following 'dd', 'wa', 'wb', 'pp', 'slm', 'pd'.</dt>
<dt>where wa- wenner alpha, slm- schlumberger, pp- pole-pole, dd- dipole-dipole</dt>
<dt><strong><code>start</code></strong> :&ensp;<code>commencing points should be at least 10 meter within the layer boundary</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>end: ending points should also be at least 10 meter within the end of the layer boundary.
num: num of electrode spacing.
mesh_quality: 34 should be the maximum. The smaller the mesh the faster the computation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_mesh(self, scheme_name, start=-30, end=30, num=21, mesh_quality=34):
    &#34;&#34;&#34;create a desired electrode configuration used investigate feature.

    parameters
    ----------
    scheme_name: should be one out of the following &#39;dd&#39;, &#39;wa&#39;, &#39;wb&#39;, &#39;pp&#39;, &#39;slm&#39;, &#39;pd&#39;.
                 where wa- wenner alpha, slm- schlumberger, pp- pole-pole, dd- dipole-dipole
    start: commencing points should be at least 10 meter within the layer boundary
    end: ending points should also be at least 10 meter within the end of the layer boundary.
    num: num of electrode spacing.
    mesh_quality: 34 should be the maximum. The smaller the mesh the faster the computation.

    &#34;&#34;&#34;
    if scheme_name.lower() not in [&#39;dd&#39;, &#39;wa&#39;, &#39;wb&#39;, &#39;pp&#39;, &#39;slm&#39;, &#39;pd&#39;]:
        raise ValueError(f&#34;{scheme_name} is not a valid scheme_name. Review documentation&#34;)

    self.scheme = ert.createData(elecs=np.linspace(start=start, stop=end, num=num),
                                 schemeName=scheme_name)
    # Update the selected scheme
    self.__sch = scheme_name
    # incorporate the created electrode configuration scheme inside the geometry
    for pos in self.scheme.sensors():
        self.geometry.createNode(pos)
        # adds refinement nodes in a distance of 10% of electrode spacing
        self.geometry.createNode(pos - [0, 0.1])

    # reassign the global electrode configuration
    self.__x_start = start
    self.__x_stop = end

    self.mesh = mt.createMesh(self.geometry, quality=mesh_quality)
    return self.mesh</code></pre>
</details>
</dd>
<dt id="root_simulator.RootSimulator.display_geometry"><code class="name flex">
<span>def <span class="ident">display_geometry</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Display all the components created at the subsurface.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_geometry(self):
    &#34;&#34;&#34;Display all the components created at the subsurface.&#34;&#34;&#34;
    return pg.show(self.geometry)</code></pre>
</details>
</dd>
<dt id="root_simulator.RootSimulator.display_inverted_img"><code class="name flex">
<span>def <span class="ident">display_inverted_img</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Display the inverted Image in a regular Mesh.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_inverted_img(self):
    &#34;&#34;&#34;Display the inverted Image in a regular Mesh.&#34;&#34;&#34;
    # plot the result of the inversion...
    _, axis = plt.subplots(1, 1)
    self.__manager.showResult(ax=axis, cMin=25, hold=True, cMax=150)
    axis.set_title(&#39;Inversion regular grid&#39;)</code></pre>
</details>
</dd>
<dt id="root_simulator.RootSimulator.display_mesh"><code class="name flex">
<span>def <span class="ident">display_mesh</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot the subsurface with the created mesh</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_mesh(self):
    &#34;&#34;&#34;Plot the subsurface with the created mesh&#34;&#34;&#34;
    return pg.show(self.mesh)</code></pre>
</details>
</dd>
<dt id="root_simulator.RootSimulator.forward_model"><code class="name flex">
<span>def <span class="ident">forward_model</span></span>(<span>self, rhomap)</span>
</code></dt>
<dd>
<div class="desc"><p>Simulate the interpolation of the mesh, scheme and resistivity values.</p>
<h2 id="parameter">Parameter</h2>
<p>rhomap: resistivity of the region. For simplicity, use the regional rhomap available,
if the individual points are not available.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def forward_model(self, rhomap):
    &#34;&#34;&#34;Simulate the interpolation of the mesh, scheme and resistivity values.

    parameter
    ---------
    rhomap: resistivity of the region. For simplicity, use the regional rhomap available,
            if the individual points are not available.
    &#34;&#34;&#34;
    data = ert.simulate(self.mesh, scheme=self.scheme, res=rhomap, noiseLevel=1,
                        noiseAbs=1e-6, seed=1337)
    # remove the values below 0
    data.remove(data[&#39;rhoa&#39;] &lt; 0)
    # print out the confirmation of the minimum value
    pg.info(&#39;Filtered rhoa (min/max)&#39;, min(data[&#39;rhoa&#39;]), max(data[&#39;rhoa&#39;]))
    self.__inv_data = data

    return ert.show(data, label=pg.unit(&#39;res&#39;))</code></pre>
</details>
</dd>
<dt id="root_simulator.RootSimulator.inversion2d"><code class="name flex">
<span>def <span class="ident">inversion2d</span></span>(<span>self, para_depth=30)</span>
</code></dt>
<dd>
<div class="desc"><p>Create an inversion of the forward model to produce the feature and the layers.</p>
<h2 id="parameter">Parameter</h2>
<p>para_depth: the slice of the depth containing our feature</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inversion2d(self, para_depth=30):
    &#34;&#34;&#34;Create an inversion of the forward model to produce the feature and the layers.

    parameter
    ---------
    para_depth: the slice of the depth containing our feature
    &#34;&#34;&#34;
    self.__manager = ert.ERTManager(self.__inv_data)
    self.__inversion = self.__manager.invert(lam=20, verbose=True, paraDepth=para_depth)

    # performs the inversion calculations and plots the inversion.
    self.__manager.showResultAndFit()
    # reassign the inversion result to the unstructured_mesh_inv
    self.__unstructured_mesh_inv = pg.Mesh(self.__manager.paraDomain)

    # perform regularization on the inverted profile
    __run_regularized = self.__perform_grid_regularization()</code></pre>
</details>
</dd>
<dt id="root_simulator.RootSimulator.plot_rhomap"><code class="name flex">
<span>def <span class="ident">plot_rhomap</span></span>(<span>self, rhomap)</span>
</code></dt>
<dd>
<div class="desc"><p>Visualize the resistivity distribution within the mesh.</p>
<p>parameter:
rhomap: nested list consisting of the region and the associated resistivity value.
example &gt;&gt; rhomap =[[1, 100], [2, 75], [4, 50], &hellip;]
The example above have four regions. This is dependent on the nature of the geometry,
layer, and feature created.</p>
<p>if the depth profile starts from 0, there will be only three regions in the overall
geometry, and thus only three resistivity map values will be needed, tied to the
region (marker). visualizing the geometry will help knowing the marker of each region.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_rhomap(self, rhomap):
    &#34;&#34;&#34;Visualize the resistivity distribution within the mesh.

    parameter:
    rhomap: nested list consisting of the region and the associated resistivity value.
    example &gt;&gt; rhomap =[[1, 100], [2, 75], [4, 50], ...]
    The example above have four regions. This is dependent on the nature of the geometry,
    layer, and feature created.

    if the depth profile starts from 0, there will be only three regions in the overall
    geometry, and thus only three resistivity map values will be needed, tied to the
    region (marker). visualizing the geometry will help knowing the marker of each region.
    &#34;&#34;&#34;
    self.__rhomap = rhomap
    return pg.show(self.mesh, data=self.__rhomap, label=pg.unit(&#39;res&#39;), showMesh=True)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="root_simulator.RootSimulator" href="#root_simulator.RootSimulator">RootSimulator</a></code></h4>
<ul class="">
<li><code><a title="root_simulator.RootSimulator.animate_simulation" href="#root_simulator.RootSimulator.animate_simulation">animate_simulation</a></code></li>
<li><code><a title="root_simulator.RootSimulator.create_geom" href="#root_simulator.RootSimulator.create_geom">create_geom</a></code></li>
<li><code><a title="root_simulator.RootSimulator.create_mesh" href="#root_simulator.RootSimulator.create_mesh">create_mesh</a></code></li>
<li><code><a title="root_simulator.RootSimulator.display_geometry" href="#root_simulator.RootSimulator.display_geometry">display_geometry</a></code></li>
<li><code><a title="root_simulator.RootSimulator.display_inverted_img" href="#root_simulator.RootSimulator.display_inverted_img">display_inverted_img</a></code></li>
<li><code><a title="root_simulator.RootSimulator.display_mesh" href="#root_simulator.RootSimulator.display_mesh">display_mesh</a></code></li>
<li><code><a title="root_simulator.RootSimulator.forward_model" href="#root_simulator.RootSimulator.forward_model">forward_model</a></code></li>
<li><code><a title="root_simulator.RootSimulator.inversion2d" href="#root_simulator.RootSimulator.inversion2d">inversion2d</a></code></li>
<li><code><a title="root_simulator.RootSimulator.plot_rhomap" href="#root_simulator.RootSimulator.plot_rhomap">plot_rhomap</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>