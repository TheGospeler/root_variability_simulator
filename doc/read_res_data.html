<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>read_res_data API documentation</title>
<meta name="description" content="importing dependency modules." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>read_res_data</code></h1>
</header>
<section id="section-intro">
<p>importing dependency modules.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;importing dependency modules.&#34;&#34;&#34;
import os
import numpy as np
import pybert as pb
import pygimli as pg


def supersting_processing(file, col=(-4, -1), row=1, save_file=False):
    &#34;&#34;&#34;Read in the supersting file and extract the measured res. values and electrodes arrangement.

    The Supersting file has a standard output format. The total number of records measured is
    situated at the end of the second row.

    The supersting_processing function returns the following in an array: resistance, apparent
    resistivity, current electrodes(xyz), and potential electrodes(xyz), from the supersting file.

    Depending on the information you need, you might just need to slightly adjust some parameters
    to get what you need. See the SuperSting Manual for column positions of information needed.

    Dependence: os, numpy
    Parameters: file- The name of the file should be in the current directory or the path should be
    added.
        row- The row shouldn&#39;t change except in case of special cases.
        col- The default used is hundreds of points. if the record is not up to hundred,
        change to [-3, -1], if total points are up to a thousand, change to [-5:-1].
        save_file- boolean. To save the file, change the parameter to True to save as .txt.
    &#34;&#34;&#34;
    if not os.path.isfile(file):
        raise ValueError(f&#34;{file} does not exist, make sure file is in the same directory&#34;)

    with open(file, &#39;r&#39;, encoding=&#39;utf-8&#39;) as fil:
        supersting_file = fil.readlines()

    # Get the number of records automatically
    for char in range(5, 1, -1):
        last_line = supersting_file[1][-char:-1]  # The number of records may not exceed 10,000s
        if isinstance(int(last_line), int):
            check_col = int(last_line)
            break

    if type(int(supersting_file[row][col[0]:col[1]])) not in [int]:
        raise ValueError(&#39;Please make sure you enter the correct col position&#39;)

    record = int(supersting_file[row][col[0]:col[1]])

    # overrides if the user enters a wrong record position that might break the code
    if check_col &gt; record:
        record = check_col

    # remove the header
    supersting = supersting_file[3:]

    # The position of the resistance, resistivity and the ABMN (xyz for each):
    relevant_col = [4, 7, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]

    # create the numpy array size to accommodate the resistance, resistivity and ABMN files
    data = np.ones((record, len(relevant_col)))

    # extract each line of the supersting file and separate each information. filling the array
    for i, _ in enumerate(supersting):
        line = supersting[i].replace(&#39;,&#39;, &#34; &#34;).split()
        for j, _ in enumerate(relevant_col):
            data[i][j] = line[relevant_col[j]]

    if save_file:
        np.savetxt(f&#34;{file[5:-4]}_res.dat&#34;, data, header=&#39;R rhoa A(xyz) B(xyz) M(xyz) N(xyz)&#39;)

    return data


def standardized_bert(file_name, precision=2, save_file=False):
    &#34;&#34;&#34;Standardized_bert function returns the required data needed for the BERT model.

    Dependencies: numpy, pybert, pygimli
    Parameters: file_name- The supersting input file.
                precision- default is set to 2. It is used to create the pseudo data used
                for inversion.
                save_file- boolean. To save the file, change the parameter to True to save
                as .txt.

    The output consist of the topography and the ABMN electrode position with the apparent
    resistivity.
    &#34;&#34;&#34;
    if not os.path.isfile(file_name):
        raise ValueError(&#34;{file_name} does not exist, make sure file is in the same directory&#34;)

    processed_file = supersting_processing(file_name)
    # extract the xyz positions of the array and stack them vertically
    a_pos = processed_file[:, 2:5]
    b_pos = processed_file[:, 5:8]
    m_pos = processed_file[:, 8:11]
    n_pos = processed_file[:, 11:14]

    electrode_pos = np.vstack((a_pos, b_pos, m_pos, n_pos))

    # rounds the floats in the array to the nearest integer tending to zero
    pseudo_data = 100 ** precision
    datafix = np.fix(electrode_pos * pseudo_data) / pseudo_data + 0.0

    # gets the actual electrodes numbering of the ABMN(elect_arr) electrodes and
    # create synthetic data.
    dtype = np.dtype((np.void, datafix.dtype.itemsize * datafix.shape[1]))
    byte = np.ascontiguousarray(datafix).view(dtype)
    _, a_current = np.unique(byte, return_index=True)
    _, b_current = np.unique(byte, return_inverse=True)

    # get electrode configuration and obtain the forward and reverse index
    org_pos = np.unique(byte).view(datafix.dtype).reshape(-1, datafix.shape[1])
    _, rev_ind = a_current, b_current

    # create an instance of the pybert DataContainerERT
    data = pg.DataContainerERT()
    for ipos in org_pos:
        data.createSensor(ipos)

    # Add more information from the supersting file
    all_info = np.genfromtxt(file_name, delimiter=&#39;,&#39;, skip_header=3)

    data.resize(len(all_info))
    elect_arr = rev_ind.reshape(4, -1).T

    for i, abmn in enumerate(elect_arr):
        ind = [int(ii) for ii in abmn]
        data.createFourPointData(i, *ind)  # ind[1], ind[0], ind[2], ind[3])

    data.set(&#39;i&#39;, all_info[:, 6] * 1e-3)
    data.set(&#39;u&#39;, all_info[:, 4] * data(&#39;i&#39;))  # U=R*I
    data.set(&#39;err&#39;, all_info[:, 5] * 0.001)
    data.set(&#39;rhoa&#39;, all_info[:, 7])
    if all_info.shape[1] &gt; 30:
        data.set(&#39;ip&#39;, all_info[:, 30] * 1000)  # M integrated in msec
        for i in range(6):
            data.set(&#39;ip&#39; + str(i + 1), all_info[:, 24 + i])

    data.markValid(data(&#39;rhoa&#39;) &gt; 0)
    data.checkDataValidity()
    data.sortSensorsX()

    # save the file in .dat format and can be visualized using notepad or any text application.
    if save_file:
        # The string format used is typical to how I am reading my file.
        # If the data is present in the directory, change &#39;5:-4&#39; to &#39;:-4&#39;
        pb.exportData(data, f&#39;{file_name[5:-4]}.dat&#39;)

    return data</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="read_res_data.standardized_bert"><code class="name flex">
<span>def <span class="ident">standardized_bert</span></span>(<span>file_name, precision=2, save_file=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Standardized_bert function returns the required data needed for the BERT model.</p>
<p>Dependencies: numpy, pybert, pygimli
Parameters: file_name- The supersting input file.
precision- default is set to 2. It is used to create the pseudo data used
for inversion.
save_file- boolean. To save the file, change the parameter to True to save
as .txt.</p>
<p>The output consist of the topography and the ABMN electrode position with the apparent
resistivity.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def standardized_bert(file_name, precision=2, save_file=False):
    &#34;&#34;&#34;Standardized_bert function returns the required data needed for the BERT model.

    Dependencies: numpy, pybert, pygimli
    Parameters: file_name- The supersting input file.
                precision- default is set to 2. It is used to create the pseudo data used
                for inversion.
                save_file- boolean. To save the file, change the parameter to True to save
                as .txt.

    The output consist of the topography and the ABMN electrode position with the apparent
    resistivity.
    &#34;&#34;&#34;
    if not os.path.isfile(file_name):
        raise ValueError(&#34;{file_name} does not exist, make sure file is in the same directory&#34;)

    processed_file = supersting_processing(file_name)
    # extract the xyz positions of the array and stack them vertically
    a_pos = processed_file[:, 2:5]
    b_pos = processed_file[:, 5:8]
    m_pos = processed_file[:, 8:11]
    n_pos = processed_file[:, 11:14]

    electrode_pos = np.vstack((a_pos, b_pos, m_pos, n_pos))

    # rounds the floats in the array to the nearest integer tending to zero
    pseudo_data = 100 ** precision
    datafix = np.fix(electrode_pos * pseudo_data) / pseudo_data + 0.0

    # gets the actual electrodes numbering of the ABMN(elect_arr) electrodes and
    # create synthetic data.
    dtype = np.dtype((np.void, datafix.dtype.itemsize * datafix.shape[1]))
    byte = np.ascontiguousarray(datafix).view(dtype)
    _, a_current = np.unique(byte, return_index=True)
    _, b_current = np.unique(byte, return_inverse=True)

    # get electrode configuration and obtain the forward and reverse index
    org_pos = np.unique(byte).view(datafix.dtype).reshape(-1, datafix.shape[1])
    _, rev_ind = a_current, b_current

    # create an instance of the pybert DataContainerERT
    data = pg.DataContainerERT()
    for ipos in org_pos:
        data.createSensor(ipos)

    # Add more information from the supersting file
    all_info = np.genfromtxt(file_name, delimiter=&#39;,&#39;, skip_header=3)

    data.resize(len(all_info))
    elect_arr = rev_ind.reshape(4, -1).T

    for i, abmn in enumerate(elect_arr):
        ind = [int(ii) for ii in abmn]
        data.createFourPointData(i, *ind)  # ind[1], ind[0], ind[2], ind[3])

    data.set(&#39;i&#39;, all_info[:, 6] * 1e-3)
    data.set(&#39;u&#39;, all_info[:, 4] * data(&#39;i&#39;))  # U=R*I
    data.set(&#39;err&#39;, all_info[:, 5] * 0.001)
    data.set(&#39;rhoa&#39;, all_info[:, 7])
    if all_info.shape[1] &gt; 30:
        data.set(&#39;ip&#39;, all_info[:, 30] * 1000)  # M integrated in msec
        for i in range(6):
            data.set(&#39;ip&#39; + str(i + 1), all_info[:, 24 + i])

    data.markValid(data(&#39;rhoa&#39;) &gt; 0)
    data.checkDataValidity()
    data.sortSensorsX()

    # save the file in .dat format and can be visualized using notepad or any text application.
    if save_file:
        # The string format used is typical to how I am reading my file.
        # If the data is present in the directory, change &#39;5:-4&#39; to &#39;:-4&#39;
        pb.exportData(data, f&#39;{file_name[5:-4]}.dat&#39;)

    return data</code></pre>
</details>
</dd>
<dt id="read_res_data.supersting_processing"><code class="name flex">
<span>def <span class="ident">supersting_processing</span></span>(<span>file, col=(-4, -1), row=1, save_file=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Read in the supersting file and extract the measured res. values and electrodes arrangement.</p>
<p>The Supersting file has a standard output format. The total number of records measured is
situated at the end of the second row.</p>
<p>The supersting_processing function returns the following in an array: resistance, apparent
resistivity, current electrodes(xyz), and potential electrodes(xyz), from the supersting file.</p>
<p>Depending on the information you need, you might just need to slightly adjust some parameters
to get what you need. See the SuperSting Manual for column positions of information needed.</p>
<p>Dependence: os, numpy
Parameters: file- The name of the file should be in the current directory or the path should be
added.
row- The row shouldn't change except in case of special cases.
col- The default used is hundreds of points. if the record is not up to hundred,
change to [-3, -1], if total points are up to a thousand, change to [-5:-1].
save_file- boolean. To save the file, change the parameter to True to save as .txt.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def supersting_processing(file, col=(-4, -1), row=1, save_file=False):
    &#34;&#34;&#34;Read in the supersting file and extract the measured res. values and electrodes arrangement.

    The Supersting file has a standard output format. The total number of records measured is
    situated at the end of the second row.

    The supersting_processing function returns the following in an array: resistance, apparent
    resistivity, current electrodes(xyz), and potential electrodes(xyz), from the supersting file.

    Depending on the information you need, you might just need to slightly adjust some parameters
    to get what you need. See the SuperSting Manual for column positions of information needed.

    Dependence: os, numpy
    Parameters: file- The name of the file should be in the current directory or the path should be
    added.
        row- The row shouldn&#39;t change except in case of special cases.
        col- The default used is hundreds of points. if the record is not up to hundred,
        change to [-3, -1], if total points are up to a thousand, change to [-5:-1].
        save_file- boolean. To save the file, change the parameter to True to save as .txt.
    &#34;&#34;&#34;
    if not os.path.isfile(file):
        raise ValueError(f&#34;{file} does not exist, make sure file is in the same directory&#34;)

    with open(file, &#39;r&#39;, encoding=&#39;utf-8&#39;) as fil:
        supersting_file = fil.readlines()

    # Get the number of records automatically
    for char in range(5, 1, -1):
        last_line = supersting_file[1][-char:-1]  # The number of records may not exceed 10,000s
        if isinstance(int(last_line), int):
            check_col = int(last_line)
            break

    if type(int(supersting_file[row][col[0]:col[1]])) not in [int]:
        raise ValueError(&#39;Please make sure you enter the correct col position&#39;)

    record = int(supersting_file[row][col[0]:col[1]])

    # overrides if the user enters a wrong record position that might break the code
    if check_col &gt; record:
        record = check_col

    # remove the header
    supersting = supersting_file[3:]

    # The position of the resistance, resistivity and the ABMN (xyz for each):
    relevant_col = [4, 7, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]

    # create the numpy array size to accommodate the resistance, resistivity and ABMN files
    data = np.ones((record, len(relevant_col)))

    # extract each line of the supersting file and separate each information. filling the array
    for i, _ in enumerate(supersting):
        line = supersting[i].replace(&#39;,&#39;, &#34; &#34;).split()
        for j, _ in enumerate(relevant_col):
            data[i][j] = line[relevant_col[j]]

    if save_file:
        np.savetxt(f&#34;{file[5:-4]}_res.dat&#34;, data, header=&#39;R rhoa A(xyz) B(xyz) M(xyz) N(xyz)&#39;)

    return data</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="read_res_data.standardized_bert" href="#read_res_data.standardized_bert">standardized_bert</a></code></li>
<li><code><a title="read_res_data.supersting_processing" href="#read_res_data.supersting_processing">supersting_processing</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>